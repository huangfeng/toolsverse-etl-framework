<?xml version="1.0" encoding="UTF-8"?>
<mssqlserver name="mssqlserver" type="0">
    <nodes>
        <node name="Aggregate Functions" type="0">
            <nodes>
                <node code="AVG($expression$)" name="avg - Computes the average of a column, ignoring any NULL values." type="1"/>
                <node code="AVG($scope$ $expression$)" name="avg2 - Computes the average of a column, ignoring any NULL values." type="1"/>
                <node code="BINARY_CHECKSUM($more_scope$)" name="binary_checksum - Returns a binary checksum for a row in a table or a list of expressions. This function is useful for detecting changes in a row." type="1"/>
                <node code="BINARY_CHECKSUM($more_scope$)" name="binary_checksum2 - Returns a binary checksum for a row in a table or a list of expressions. This function is useful for detecting changes in a row." type="1"/>
                <node code="CHECKSUM($more_scope$)" name="checksum - Returns a checksum for a row in a table or a list of expressions. This function is useful for building hash indexes." type="1"/>
                <node code="CHECKSUM($more_scope$)" name="checksum2 - Returns a checksum for a row in a table or a list of expressions. This function is useful for building hash indexes." type="1"/>
                <node code="CHECKSUM_AGG($expression$)" name="checksum_agg - Returns a checksum for values in the group. This function ignores NULL values." type="1"/>
                <node code="CHECKSUM_AGG($scope$ $expression$)" name="checksum_agg2 - Returns a checksum for values in the group. This function ignores NULL values." type="1"/>
                <node code="COUNT($expression$)" name="count - Counts the total number of rows if ALL is defined in scope; or counts the number of unique rows if DISTINCT is defined in scope. This function returns an integer." type="1"/>
                <node code="COUNT($scope$ $expression$)" name="count2 - Counts the total number of rows if ALL is defined in scope; or counts the number of unique rows if DISTINCT is defined in scope. This function returns an integer." type="1"/>
                <node code="COUNT_BIG($expression$)" name="count_big - Counts the total number of rows if ALL is defined in scope; or counts the number of unique rows if DISTINCT is defined in scope. This function returns a bigint value." type="1"/>
                <node code="COUNT_BIG($scope$ $expression$)" name="count_big2 - Counts the total number of rows if ALL is defined in scope; or counts the number of unique rows if DISTINCT is defined in scope. This function returns a bigint value." type="1"/>
                <node code="GROUPING($column_name$)" name="grouping - Returns an additional column with a value of 1 if the row is added by either the CUBE or ROLLUP operator, or returns an additional column with a value of 0. This function must be used in conjunction with a GROUP BY clause that contains either a CUBE or ROLLUP operator." type="1"/>
                <node code="MAX($expression$)" name="max - Finds the maximum value in a column." type="1"/>
                <node code="MAX($scope$ $expression$)" name="max2 - Finds the maximum value in a column." type="1"/>
                <node code="MIN($expression$)" name="min - Finds the minimum value in a column." type="1"/>
                <node code="MIN($scope$ $expression$)" name="min2 - Finds the minimum value in a column." type="1"/>
                <node code="STDEV($expression$)" name="stdev - Returns the standard deviation of values in the column." type="1"/>
                <node code="STDEVP($expression$)" name="stdevp - Returns the standard deviation for the population of values in the column." type="1"/>
                <node code="SUM($expression$)" name="sum - Computes the sum of values for numeric columns only. This function ignores NULL values." type="1"/>
                <node code="SUM($scope$ $expression$)" name="sum2 - Computes the sum of values for numeric columns only. This function ignores NULL values." type="1"/>
                <node code="VAR($expression$)" name="var - Returns the statistical variance in a column." type="1"/>
                <node code="VARP($expression$)" name="varp - Returns statistical variance for a population for all values in the column." type="1"/>
            </nodes>
        </node>
        <node name="Comment Statements" type="0">
            <nodes>
                <node code="-- end region" name="endregion - End a collapsible code region" type="1"/>
                <node code="-- region $name$&#xa;$selected$$end$&#xa;-- endregion" name="region - Starts a collapsible code region." type="1"/>
            </nodes>
        </node>
        <node name="Configuration Functions" type="0">
            <nodes>
                <node code="@@DATEFIRST" name="datefirst - Returns a number representing the day of the week (1 for Monday, 2 for Tuesday...)." type="1"/>
                <node code="@@DBTS" name="dbts - Returns the current value of TIMESTAMP for the current database." type="1"/>
                <node code="@@LANGID" name="langid - Returns the language identifier for the language currently in use." type="1"/>
                <node code="@@LANGUAGE" name="language - Returns the language currently in use." type="1"/>
                <node code="@@LOCK_TIMEOUT" name="lock_timeout - Returns the number of milliseconds the connection waits for a resource that is currently blocked. After that time period, the connection times out and returns an error." type="1"/>
                <node code="@@MAX_CONNECTIONS" name="max_connections - Returns the maximum allowable connections on the server." type="1"/>
                <node code="@@MAX_PRECISION" name="max_precision - Returns the maximum precision allowed for decimal and numeric data types." type="1"/>
                <node code="@@NESTLEVEL" name="nestlevel - Returns the current level of stored procedure nesting. If there are no currently executing nested procedures, this function returns a zero." type="1"/>
                <node code="@@OPTIONS" name="options - Returns a bitmask of currently active SET options. Some SET options can be altered by each user; however, each connection starts with the same options, as configured by the system administrator." type="1"/>
                <node code="@@REMSERVER" name="remserver - Returns the name of the remote SQL Server." type="1"/>
                <node code="@@SERVERNAME" name="servername - Returns the name of the local SQL Server." type="1"/>
                <node code="@@SERVICENAME" name="servicename - Returns the name of the registry key under which the SQL Server is running. The default instance returns MSSQLSERVER, named instances return the name of the instance." type="1"/>
                <node code="@@SPID" name="spid - Returns the system process identifier for the current connection." type="1"/>
                <node code="@@TEXTSIZE" name="textsize - Returns the current value of TEXTSIZE, which is the maximum size of the TEXT and IMAGE columns that can be returned by a SELECT statement." type="1"/>
                <node code="@@VERSION" name="version - Returns the date, version, and processor type for the local SQL Server." type="1"/>
            </nodes>
        </node>
        <node name="Cursor Functions" type="0">
            <nodes>
                <node code="@@CURSOR_ROWS" name="cursor_rows - Returns the number of rows in the last opened cursor (for the current connection)." type="1"/>
                <node code="CURSOR_STATUS($cursor_type$, $cursor_name_or_var$)" name="cursor_status - Indicates whether the procedure has returned a cursor and result set." type="1"/>
                <node code="@@FETCH_STATUS" name="fetch_status - Returns the status of the last FETCH statement of the connection, executed against any cursor opened on the current connection." type="1"/>
            </nodes>
        </node>
        <node name="Date and Time Functions" type="0">
            <nodes>
                <node code="DATEADD($_datepart$, $datenumber$, $_date$)" name="dateadd - Adds a number of dateparts (e.g. days, weeks, minutes, years) to a datetime value." type="1"/>
                <node code="DATEDIFF($_datepart$, $startdate$, $enddate$)" name="datediff - Calculates the difference between two datetime values expressed in certain dateparts." type="1"/>
                <node code="DATENAME($_datepart$, $_date$)" name="datename - Returns the name of a datepart (e.g. month) of a datetime argument." type="1"/>
                <node code="DATEPART($_datepart$, $_date$)" name="datepart - Returns the value of a datepart (e.g. hour) of a datetime argument." type="1"/>
                <node code="DAY($_date$)" name="day - Returns an integer value representing the day of the date provided as a parameter." type="1"/>
                <node code="GETDATE()" name="getdate - Returns the current date and time." type="1"/>
                <node code="GETUTCDATE()" name="getutcdate - Returns the current UTC time." type="1"/>
                <node code="MONTH($_date$)" name="month - Returns the month part of the specified date." type="1"/>
                <node code="YEAR($_date$)" name="year - Returns the year part of the specified date." type="1"/>
            </nodes>
        </node>
        <node name="DBA Queries" type="0">
            <nodes>
                <node name="Backup - Restore" type="0">
                    <nodes>
                        <node code="-- Last 100 database backups performed&#xa;SELECT TOP 100 &#xa;  db.name &quot;DatabaseName&quot;, &#xa;  bs.server_name &quot;ServerName&quot;,&#xa;  bs.backup_set_id &quot;BackupSetID&quot;,&#xa;  bs.name &quot;Name&quot;,&#xa;  CASE bs.type&#xa;    WHEN 'D' THEN 'D-Database'&#xa;    WHEN 'I' THEN 'I-Differential'&#xa;    WHEN 'L' THEN 'L-Log'&#xa;    WHEN 'F' THEN 'F-File'&#xa;    WHEN 'G' THEN 'G-Differential'&#xa;    WHEN 'P' THEN 'P-Partial'&#xa;    WHEN 'Q' THEN 'Q-DifferentialPartial'&#xa;    ELSE bs.type&#xa;  END &quot;Type&quot;, &#xa;  bs.backup_start_date &quot;StartDate&quot;,&#xa;  DATEDIFF(mi, bs.backup_start_date, bs.backup_finish_date) &quot;Duration(Min)&quot;,&#xa;  CAST(bs.backup_size/1024/1024 AS DECIMAL(11,2)) &quot;Size(MB)&quot;,&#xa;  bs.user_name &quot;UserName&quot;,&#xa;  CAST(bs.software_major_version AS VARCHAR(3)) + '.' + CAST(bs.software_minor_version AS VARCHAR(3)) + '.' + CAST(bs.software_build_version AS VARCHAR(5)) &quot;SQLServerVersion&quot;&#xa;  -- Uncomment the following line for additional Backup data&#xa;  -- ,bs.*&#xa;FROM&#xa;  master.dbo.sysdatabases db &#xa;INNER JOIN &#xa;  msdb.dbo.backupset bs &#xa;ON&#xa;  bs.database_name = db.name &#xa;ORDER BY &#xa;  bs.backup_start_date desc;&#xa;" name="Backup History - Returns a list of the last 100 database backups performed" type="1"/>
                        <node code="-- Performs a LiteSpeed full database backup&#xa;DECLARE @DBName     NVARCHAR(128);&#xa;DECLARE @BackupName NVARCHAR(128);&#xa;DECLARE @Desc       NVARCHAR(128);&#xa;DECLARE @BackupDir  NVARCHAR(128);&#xa;DECLARE @BackupFile NVARCHAR(128);&#xa;&#xa;SET @DBName = N'$DatabaseName$';&#xa;SET @BackupName = @DBName + N' - Full Database Backup';&#xa;SET @Desc = N'Full Backup of ' + @DBName + ' on' + CONVERT(NVARCHAR(20), GETDATE(), 120);&#xa;SET @BackupDir = N'$BackupDir$';&#xa;SET @BackupFile = N'$BackupFile$';&#xa;SET @BackupFile = @BackupDir + @BackupFile;&#xa;&#xa;EXEC master.dbo.xp_backup_database &#xa;  @database = @DBName, &#xa;  @backupname = @BackupName,&#xa;  @desc = @Desc,&#xa;  @comment = N'',&#xa;  @compressionlevel = 1,&#xa;  @filename = @BackupFile,&#xa;  @init = 1,&#xa;  @OLRMAP = 1 ,&#xa;  @with = N'SKIP', &#xa;  @with = N'STATS = 10'&#xa;  -- , @attachedfile = N'$AttachedFile$';&#xa;" name="LiteSpeed Backup - Performs a LiteSpeed full database backup" type="1"/>
                        <node code="-- Returns the last LiteSpeed full backup for each database&#xa;SELECT &#xa;  ss.srvname &quot;Server&quot;,&#xa;&#x9;ld.DatabaseName &quot;DatabaseName&quot;,&#xa;&#x9;ld.DatabaseID &quot;DatabaseID&quot;,&#xa;  CONVERT(VARCHAR(20), la.StartTime, 120) &quot;BackupDate&quot;,&#xa;&#x9;CAST(DATEDIFF(s, la.StartTime, la.FinishTime)/60.0 AS DECIMAL(10,2)) &quot;Duration(Min)&quot;,&#xa;&#x9;ls.StatusName &quot;Status&quot;&#xa;FROM &#xa;  master.dbo.sysservers ss&#xa;LEFT JOIN &#xa;  $LiteSpeedRepository$.dbo.LitespeedDatabase ld&#xa;ON &#xa;  ld.ServerName = ss.srvname&#xa;AND &#xa;  ld.Deleted = 0&#xa;LEFT JOIN &#xa;  $LiteSpeedRepository$.dbo.LitespeedActivity la&#xa;ON &#xa;  la.DatabaseID = ld.DatabaseID&#xa;AND &#xa;  la.ServerName = ss.srvname&#xa;AND la.ActivityID = (&#xa;  SELECT TOP 1 &#xa;    la2.ActivityID&#xa;  FROM &#xa;    $LiteSpeedRepository$.dbo.LitespeedActivity la2&#xa;  WHERE &#xa;    la2.DatabaseID = ld.DatabaseID&#xa;  AND &#xa;    la2.ActivityTypeID = 1&#xa;  AND &#xa;    la2.ServerName = ss.srvname&#xa;  ORDER BY &#xa;    la2.StartTime DESC)&#xa;LEFT JOIN &#xa;  $LiteSpeedRepository$.dbo.LitespeedStatusType ls&#xa;ON &#xa;  la.StatusTypeID = ls.StatusTypeID&#xa;AND&#xa;  la.StatusTypeID in (2,3)&#xa;ORDER BY &#xa;  ss.srvname,&#xa;  ld.DatabaseName;&#xa;" name="LiteSpeed Last Backup Status - Returns the last LiteSpeed full backup for each database" type="1"/>
                        <node code="-- Returns the last 100 Restore operations&#xa;SELECT TOP 100&#xa;  destination_database_name &quot;DatabaseName&quot;,&#xa;  backup_set_id &quot;BackupSetID&quot;,&#xa;  CASE restore_type&#xa;    WHEN 'D' THEN 'D-Database'&#xa;    WHEN 'F' THEN 'F-File'&#xa;    WHEN 'G' THEN 'G-Filegroup'&#xa;    WHEN 'I' THEN 'I-Differential'&#xa;    WHEN 'L' THEN 'L-Log'&#xa;    WHEN 'V' THEN 'V-VerifyOnly'&#xa;    WHEN 'R' THEN 'R-Revert'&#xa;    ELSE restore_type&#xa;  END &quot;RestoreType&quot;, &#xa;  restore_date &quot;RestoreDate&quot;,  &#xa;  [user_name] &quot;UserName&quot;, &#xa;  Case [replace]&#xa;    WHEN 1 THEN '1-Yes'&#xa;    WHEN 0 THEN '0-No'&#xa;    ELSE ''&#xa;  END &quot;Replace&quot;,&#xa;  Case recovery&#xa;    WHEN 1 THEN '1-Recovery'&#xa;    WHEN 0 THEN '0-NoRecovery'&#xa;    ELSE ''&#xa;  END &quot;Recovery&quot;,&#xa;  stop_at &quot;StopAt&quot;&#xa;  -- Uncomment the following line for additional Restore History data&#xa;  -- ,*&#xa;FROM &#xa;  msdb.dbo.restorehistory&#xa;ORDER BY&#xa;  restore_date DESC;&#xa;" name="Restore History - Returns the last 100 Restore operations" type="1"/>
                        <node code="-- Returns a list of Attached Files from a LiteSpeed backup&#xa;EXEC master.dbo.xp_restore_headeronly &#xa;  @filename = N'$BackupFile$', &#xa;  @HeaderDetails='attachedfiles';&#xa;" name="LiteSpeed List Attached Files - Returns a list of Attached Files from a LiteSpeed backup" type="1"/>
                        <node code="-- Restores Attached Files from a LiteSpeed backup&#xa;EXEC master.dbo.xp_restore_attachedfilesonly&#xa;  @filename= N'$BackupFile$',&#xa;  @attachedfile = N'$AttachedFile$ to $DestinationFileName$' &#xa;  -- ,@attachedfile = N'OptionalAttachedFile'&#xa;" name="LiteSpeed Restore Attached Files - Restores one or more attached files from a LiteSpeed backup" type="1"/>
                    </nodes>
                </node>
                <node name="Jobs" type="0">
                    <nodes>
                        <node code="-- Returns a list of jobs for SQL Server 2000&#xa;SELECT &#xa;  a.job_id &quot;JobID&quot;,&#xa;  a.name &quot;JobName&quot;,&#xa;  CASE a.enabled &#xa;    WHEN 1 THEN 'Enabled' &#xa;    ELSE 'Disabled' &#xa;  END &quot;Status&quot;,  &#xa;  a.description &quot;Description&quot;,&#xa;  CASE b.freq_type    &#xa;    WHEN 1 THEN 'Once'&#xa;    WHEN 4 THEN 'Daily' + &#xa;      CASE &#xa;        WHEN b.freq_interval > 1 THEN ' (Every ' + CAST(b.freq_interval AS VARCHAR(5)) + ' day(s))'&#xa;        ELSE ''&#xa;      END&#xa;    WHEN 8 THEN 'Weekly' &#xa;    WHEN 16 THEN 'Monthly'&#xa;    WHEN 32 THEN 'Monthly'&#xa;    WHEN 64 THEN 'Agent Starts'&#xa;    WHEN 128 THEN 'Computer Idle'&#xa;    ELSE '(Unknown)'&#xa;  END &quot;Frequency&quot;,&#xa;  b.active_start_date &quot;StartDate&quot;,&#xa;  b.active_start_time &quot;StartTime&quot;,&#xa;  b.active_end_date &quot;EndDate&quot;,&#xa;  b.active_end_time &quot;EndTime&quot;                    &#xa;FROM &#xa;  msdb..sysjobschedules b &#xa;INNER JOIN &#xa;  msdb..sysjobs a&#xa;ON &#xa;  a.job_id = b.job_id &#xa;ORDER BY &#xa;  a.name;&#xa;" name="Job Listing (2000) - Returns a list of jobs (SQL Server 2000)" type="1"/>
                        <node code="-- Returns a list of jobs for SQL Server 2005+&#xa;SELECT &#xa;  a.job_id &quot;JobID&quot;,&#xa;  a.name &quot;JobName&quot;,&#xa;  CASE a.enabled &#xa;    WHEN 1 THEN 'Enabled' &#xa;    ELSE 'Disabled' &#xa;  END &quot;Status&quot;,  &#xa;  a.description &quot;Description&quot;,&#xa;  CASE c.freq_type    &#xa;    WHEN 1 THEN 'Once'&#xa;    WHEN 4 THEN 'Daily' + &#xa;      CASE &#xa;        WHEN c.freq_interval > 1 THEN ' (Every ' + CAST(c.freq_interval AS VARCHAR(5)) + ' day(s))'&#xa;        ELSE ''&#xa;      END&#xa;    WHEN 8 THEN 'Weekly' &#xa;    WHEN 16 THEN 'Monthly'&#xa;    WHEN 32 THEN 'Monthly'&#xa;    WHEN 64 THEN 'Agent Starts'&#xa;    WHEN 128 THEN 'Computer Idle'&#xa;    ELSE '(Unknown)'&#xa;  END &quot;Frequency&quot;,&#xa;  c.active_start_date &quot;StartDate&quot;,&#xa;  c.active_start_time &quot;StartTime&quot;,&#xa;  c.active_end_date &quot;EndDate&quot;,&#xa;  c.active_end_time &quot;EndTime&quot;                    &#xa;FROM &#xa;  msdb..sysschedules c&#xa;INNER JOIN &#xa;  msdb..sysjobschedules b &#xa;ON &#xa;  c.schedule_id=b.schedule_id&#xa;INNER JOIN &#xa;  msdb..sysjobs a&#xa;ON &#xa;  a.job_id = b.job_id &#xa;ORDER BY &#xa;  a.name;&#xa;" name="Job Listing - Returns a list of jobs (SQL Server 2005, 2008)" type="1"/>
                    </nodes>
                </node>
                <node name="Server" type="0">
                    <nodes>
                        <node code="-- Returns server configuration information (SQL Server 2000)&#xa;SELECT&#xa;  comment &quot;Name&quot;,&#xa;  config &quot;ConfigID&quot;,&#xa;  value &quot;Value&quot;,&#xa;  status &quot;Status&quot;,&#xa;  CASE status &#xa;    WHEN 0 THEN 'Static' &#xa;    WHEN 1 THEN 'Dynamic'&#xa;    WHEN 2 THEN 'Advanced'&#xa;    WHEN 3 THEN 'Dynamic, Advanced'&#xa;  END &quot;StatusDesc&quot;&#xa;FROM&#xa;  master.dbo.sysconfigures&#xa;ORDER BY&#xa;  comment;&#xa;" name="Server Configuration (2000) - Returns server configuration information (SQL Server 2000)" type="1"/>
                        <node code="-- Returns server configuration information (SQL Server 2005+)&#xa;SELECT &#xa;  name &quot;Name&quot;,&#xa;  configuration_id &quot;ConfigID&quot;,&#xa;  description &quot;Description&quot;,&#xa;  value &quot;Value&quot;,&#xa;  value_in_use &quot;ValueInUse&quot;,&#xa;  minimum &quot;Minimum&quot;,&#xa;  maximum &quot;Maximum&quot;,&#xa;  is_dynamic &quot;IsDynamic&quot;,&#xa;  is_advanced &quot;IsAdvanced&quot;&#xa;FROM &#xa;  sys.configurations&#xa;ORDER BY&#xa;  name;&#xa;" name="Server Configuration - Returns server configuration information (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns SQL Server information (SQL Server 2000)&#xa;SELECT 'ServerName' &quot;Name&quot;, SERVERPROPERTY('ServerName') &quot;Value&quot; &#xa;UNION ALL &#xa;SELECT 'InstanceName', SERVERPROPERTY('InstanceName') &#xa;UNION ALL &#xa;SELECT 'MachineName', SERVERPROPERTY('MachineName') &#xa;UNION ALL &#xa;SELECT 'ProductVersion', SERVERPROPERTY('ProductVersion') &#xa;UNION ALL &#xa;SELECT 'ProductLevel', SERVERPROPERTY('ProductLevel') &#xa;UNION ALL &#xa;SELECT 'Edition', SERVERPROPERTY('Edition') &#xa;UNION ALL &#xa;SELECT 'EngineEdition', SERVERPROPERTY('EngineEdition') &#xa;UNION ALL &#xa;SELECT 'EngineEditionDesc', &#xa;  CASE SERVERPROPERTY('EngineEdition') &#xa;    WHEN 1 THEN 'Personal/Desktop Engine'&#xa;    WHEN 2 THEN 'Standard'&#xa;    WHEN 3 THEN 'Enterprise'&#xa;  END&#xa;UNION ALL&#xa;SELECT 'Collation', SERVERPROPERTY('Collation')&#xa;UNION ALL &#xa;SELECT 'IsClustered', SERVERPROPERTY('IsClustered') &#xa;UNION ALL &#xa;SELECT 'IsFullTextInstalled', SERVERPROPERTY('IsFullTextInstalled') &#xa;UNION ALL &#xa;SELECT 'IsIntegratedSecurityOnly', SERVERPROPERTY('IsIntegratedSecurityOnly') &#xa;UNION ALL &#xa;SELECT 'IsSingleUser', SERVERPROPERTY('IsSingleUser') &#xa;UNION ALL &#xa;SELECT 'IsSyncWithBackup', SERVERPROPERTY('IsSyncWithBackup') &#xa;UNION ALL &#xa;SELECT 'LicenseType', SERVERPROPERTY('LicenseType') &#xa;UNION ALL &#xa;SELECT 'NumLicenses', SERVERPROPERTY('NumLicenses') &#xa;UNION ALL &#xa;SELECT 'ProcessID', SERVERPROPERTY('ProcessID');&#xa;" name="Server Information (2000) - Returns SQL Server information (SQL Server 2000)" type="1"/>
                        <node code="-- Returns SQL Server information (SQL Server 2005)&#xa;SELECT 'ServerName' &quot;Name&quot;, SERVERPROPERTY('ServerName') &quot;Value&quot; &#xa;UNION ALL &#xa;SELECT 'InstanceName', SERVERPROPERTY('InstanceName') &#xa;UNION ALL &#xa;SELECT 'MachineName', SERVERPROPERTY('MachineName') &#xa;UNION ALL &#xa;SELECT 'ComputerNamePhysicalNetBIOS', SERVERPROPERTY('ComputerNamePhysicalNetBIOS') &#xa;UNION ALL &#xa;SELECT 'ProductVersion', SERVERPROPERTY('ProductVersion') &#xa;UNION ALL &#xa;SELECT 'ProductLevel', SERVERPROPERTY('ProductLevel') &#xa;UNION ALL &#xa;SELECT 'Edition', SERVERPROPERTY('Edition') &#xa;UNION ALL &#xa;SELECT 'EditionID', SERVERPROPERTY('EditionID') &#xa;UNION ALL &#xa;SELECT 'EngineEdition', SERVERPROPERTY('EngineEdition') &#xa;UNION ALL &#xa;SELECT 'EngineEditionDesc', &#xa;  CASE SERVERPROPERTY('EngineEdition') &#xa;    WHEN 1 THEN 'Personal/Desktop Engine'&#xa;    WHEN 2 THEN 'Standard'&#xa;    WHEN 3 THEN 'Enterprise'&#xa;    WHEN 4 THEN 'Express'&#xa;  END&#xa;UNION ALL &#xa;SELECT 'BuildClrVersion', SERVERPROPERTY('BuildClrVersion') &#xa;UNION ALL&#xa;SELECT 'Collation', SERVERPROPERTY('Collation')&#xa;UNION ALL&#xa;SELECT 'CollationID', SERVERPROPERTY('CollationID')&#xa;UNION ALL &#xa;SELECT 'LCID', SERVERPROPERTY('LCID')&#xa;UNION ALL &#xa;SELECT 'SqlCharSet', SERVERPROPERTY('SqlCharSet')&#xa;UNION ALL &#xa;SELECT 'SqlCharSetName', SERVERPROPERTY('SqlCharSetName')&#xa;UNION ALL &#xa;SELECT 'SqlSortOrder', SERVERPROPERTY('SqlSortOrder')&#xa;UNION ALL &#xa;SELECT 'SqlSortOrderName', SERVERPROPERTY('SqlSortOrderName')&#xa;UNION ALL &#xa;SELECT 'ComparisonStyle', SERVERPROPERTY('ComparisonStyle') &#xa;UNION ALL &#xa;SELECT 'IsClustered', SERVERPROPERTY('IsClustered') &#xa;UNION ALL &#xa;SELECT 'IsFullTextInstalled', SERVERPROPERTY('IsFullTextInstalled') &#xa;UNION ALL &#xa;SELECT 'IsIntegratedSecurityOnly', SERVERPROPERTY('IsIntegratedSecurityOnly') &#xa;UNION ALL &#xa;SELECT 'IsSingleUser', SERVERPROPERTY('IsSingleUser') &#xa;UNION ALL &#xa;SELECT 'ResourceLastUpdateDateTime', SERVERPROPERTY('ResourceLastUpdateDateTime') &#xa;UNION ALL &#xa;SELECT 'ResourceVersion', SERVERPROPERTY('ResourceVersion') &#xa;UNION ALL &#xa;SELECT 'LicenseType', SERVERPROPERTY('LicenseType') &#xa;UNION ALL &#xa;SELECT 'NumLicenses', SERVERPROPERTY('NumLicenses') &#xa;UNION ALL &#xa;SELECT 'ProcessID', SERVERPROPERTY('ProcessID');&#xa;" name="Server Information (2005) - Returns SQL Server information (SQL Server 2005)" type="1"/>
                        <node code="-- Returns SQL Server information (SQL Server 2008)&#xa;SELECT 'ServerName' &quot;Name&quot;, SERVERPROPERTY('ServerName') &quot;Value&quot; &#xa;UNION ALL &#xa;SELECT 'InstanceName', SERVERPROPERTY('InstanceName') &#xa;UNION ALL &#xa;SELECT 'MachineName', SERVERPROPERTY('MachineName') &#xa;UNION ALL &#xa;SELECT 'ComputerNamePhysicalNetBIOS', SERVERPROPERTY('ComputerNamePhysicalNetBIOS') &#xa;UNION ALL &#xa;SELECT 'ProductVersion', SERVERPROPERTY('ProductVersion') &#xa;UNION ALL &#xa;SELECT 'ProductLevel', SERVERPROPERTY('ProductLevel') &#xa;UNION ALL &#xa;SELECT 'Edition', SERVERPROPERTY('Edition') &#xa;UNION ALL &#xa;SELECT 'EditionID', SERVERPROPERTY('EditionID') &#xa;UNION ALL &#xa;SELECT 'EngineEdition', SERVERPROPERTY('EngineEdition') &#xa;UNION ALL &#xa;SELECT 'EngineEditionDesc', &#xa;  CASE SERVERPROPERTY('EngineEdition') &#xa;    WHEN 1 THEN 'Personal/Desktop Engine'&#xa;    WHEN 2 THEN 'Standard'&#xa;    WHEN 3 THEN 'Enterprise'&#xa;    WHEN 4 THEN 'Express'&#xa;  END&#xa;UNION ALL &#xa;SELECT 'FilestreamShareName', SERVERPROPERTY('FilestreamShareName') &#xa;UNION ALL &#xa;SELECT 'FilestreamConfiguredLevel', SERVERPROPERTY('FilestreamConfiguredLevel') &#xa;UNION ALL &#xa;SELECT 'FilestreamEffectiveLevel', SERVERPROPERTY('FilestreamEffectiveLevel') &#xa;UNION ALL &#xa;SELECT 'BuildClrVersion', SERVERPROPERTY('BuildClrVersion') &#xa;UNION ALL&#xa;SELECT 'Collation', SERVERPROPERTY('Collation')&#xa;UNION ALL&#xa;SELECT 'CollationID', SERVERPROPERTY('CollationID')&#xa;UNION ALL &#xa;SELECT 'LCID', SERVERPROPERTY('LCID')&#xa;UNION ALL &#xa;SELECT 'SqlCharSet', SERVERPROPERTY('SqlCharSet')&#xa;UNION ALL &#xa;SELECT 'SqlCharSetName', SERVERPROPERTY('SqlCharSetName')&#xa;UNION ALL &#xa;SELECT 'SqlSortOrder', SERVERPROPERTY('SqlSortOrder')&#xa;UNION ALL &#xa;SELECT 'SqlSortOrderName', SERVERPROPERTY('SqlSortOrderName')&#xa;UNION ALL &#xa;SELECT 'ComparisonStyle', SERVERPROPERTY('ComparisonStyle') &#xa;UNION ALL &#xa;SELECT 'IsClustered', SERVERPROPERTY('IsClustered') &#xa;UNION ALL &#xa;SELECT 'IsFullTextInstalled', SERVERPROPERTY('IsFullTextInstalled') &#xa;UNION ALL &#xa;SELECT 'IsIntegratedSecurityOnly', SERVERPROPERTY('IsIntegratedSecurityOnly') &#xa;UNION ALL &#xa;SELECT 'IsSingleUser', SERVERPROPERTY('IsSingleUser') &#xa;UNION ALL &#xa;SELECT 'ResourceLastUpdateDateTime', SERVERPROPERTY('ResourceLastUpdateDateTime') &#xa;UNION ALL &#xa;SELECT 'ResourceVersion', SERVERPROPERTY('ResourceVersion') &#xa;UNION ALL &#xa;SELECT 'LicenseType', SERVERPROPERTY('LicenseType') &#xa;UNION ALL &#xa;SELECT 'NumLicenses', SERVERPROPERTY('NumLicenses') &#xa;UNION ALL &#xa;SELECT 'ProcessID', SERVERPROPERTY('ProcessID');&#xa;" name="Server Information (2008) - Returns SQL Server information (SQL Server 2008)" type="1"/>
                        <node code="-- Returns the memory allocation by the instance &#xa;-- (SQL Server 2005, 2008)&#xa;SELECT&#xa;&#x9;type &quot;MemType&quot;,&#xa;&#x9;sum(single_pages_kb) &quot;SinglePageMem(KB)&quot;,&#xa;&#x9;sum(multi_pages_kb) &quot;MultiPageMem(KB)&quot;,&#xa;&#x9;sum(virtual_memory_reserved_kb) &quot;VirtualMemReserved(KB)&quot;,&#xa;&#x9;sum(virtual_memory_committed_kb) &quot;VirtualMemCommitted(KB)&quot;,&#xa;&#x9;sum(shared_memory_reserved_kb) as &quot;SharedMemReserved(KB)&quot;, &#xa;&#x9;sum(shared_memory_committed_kb) as &quot;SharedMemCommitted(KB)&quot;,&#xa;&#x9;sum(awe_allocated_kb) &quot;AWEAllocated(KB)&quot;&#xa;FROM&#xa;  sys.dm_os_memory_clerks &#xa;GROUP BY&#xa;  type&#xa;ORDER BY &#xa;  2 DESC;&#xa;" name="Server Instance Memory - Returns the memory allocation by the instance (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns memory information for the operating system &#xa;-- (SQL Server 2008)&#xa;SELECT &#xa;  total_physical_memory_kb / 1024 &quot;PhysicalMem(MB)&quot;,&#xa;  available_physical_memory_kb / 1024 &quot;AvailablePhysicalMem(MB)&quot;,&#xa;  system_cache_kb /1024 &quot;SystemCache(MB)&quot;,&#xa;  (kernel_paged_pool_kb + kernel_nonpaged_pool_kb) / 1024 &quot;KernelPool(MB)&quot;,&#xa;  total_page_file_kb / 1024 &quot;TotalPageFile(MB)&quot;,&#xa;  available_page_file_kb / 1024 &quot;AvailablePageFile(MB)&quot;,&#xa;  system_memory_state_desc &quot;MemoryState&quot;,&#xa;  system_high_memory_signal_state &quot;SystemHighMemState&quot;,&#xa;  system_low_memory_signal_state &quot;SystemLowMemState&quot;&#xa;FROM &#xa;  sys.dm_os_sys_memory;&#xa;" name="Server OS Memory - Returns memory information for the operating system (SQL Server 2008)" type="1"/>
                    </nodes>
                </node>
                <node name="SQL Activity" type="0">
                    <nodes>
                        <node code="-- Displays the SQL Statements that are currently running &#xa;-- (SQL Server 2005, 2008)&#xa;SELECT &#xa;  er.session_id &quot;SessionID&quot; ,&#xa;  DB_NAME(er.database_id) &quot;DatabaseName&quot;,&#xa;&#x9;sp.login_name &quot;LoginName&quot;,&#xa;  sp.nt_user_name &quot;NTUserName&quot;,&#xa;&#x9;er.command &quot;Command&quot;,&#xa;&#x9;er.start_time &quot;StartTime&quot;,&#xa;&#x9;DATEDIFF(second, er.start_time, GETDATE()) &quot;Duration&quot;,&#xa;  er.status &quot;Status&quot;,&#xa;  er.wait_type &quot;WaitType&quot;,&#xa;&#x9;CASE &#xa;&#x9;  WHEN er.blocking_session_id = -2&#xa;&#x9;    THEN 'Orphaned distributed transaction'&#xa;&#x9;  WHEN er.blocking_session_id = -3&#xa;&#x9;&#x9;  THEN 'Deferred recovery transaction'&#xa;&#x9;  WHEN er.blocking_session_id = -4&#xa;&#x9;&#x9;  THEN 'Unknown'&#xa;&#x9;&#x9;ELSE&#xa;&#x9;&#x9;  CAST(er.blocking_session_id AS VARCHAR(5))&#xa;&#x9;&#x9;END &quot;BlockingSessionID&quot;,&#xa;  SUBSTRING(qt.text, er.statement_start_offset/2,&#xa;    (CASE WHEN er.statement_end_offset = -1 &#xa;       THEN LEN(CONVERT(NVARCHAR(MAX), qt.text)) * 2 &#xa;     ELSE er.statement_end_offset END &#xa;&#x9;&#x9; - er.statement_start_offset)/2) &quot;SQL&quot;,&#xa;  qt.text &quot;Batch&quot;,&#xa;  sp.program_name &quot;ProgramName&quot;,&#xa;  sp.host_name &quot;HostName&quot;,&#xa;  sp.nt_domain &quot;NTDomain&quot;&#xa;FROM &#xa;  sys.dm_exec_requests er WITH (NOLOCK)&#xa;INNER JOIN&#xa;  sys.dm_exec_sessions sp WITH (NOLOCK)&#xa;ON er.session_id = sp.session_id&#xa;CROSS APPLY &#xa;  sys.dm_exec_sql_text(er.sql_handle) as qt&#xa;WHERE &#xa;  er.session_id > 50&#xa;AND &#xa;  er.session_id != @@SPID&#xa;ORDER BY 1, 2;&#xa;" name="Active Statements - Displays the SQL Statements that are currently running (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns a list of sessions that are currently blocked (SQL Server 2005/2008)&#xa;SELECT &#xa;  tl.request_session_id &quot;BlockedSession&quot;, &#xa;  wt.blocking_session_id &quot;BlockingSession&quot;, &#xa;  CAST(wt.wait_duration_ms / 1000.0 AS DECIMAL(10,2)) &quot;WaitDuration(Sec)&quot;,&#xa;  DB_NAME(tl.resource_database_id) &quot;Database&quot;,&#xa;  SUBSTRING(st.text, (r.statement_start_offset/2) + 1,&#xa;                      ((CASE r.statement_end_offset&#xa;                          WHEN -1 THEN DATALENGTH(st.text)&#xa;                          ELSE r.statement_end_offset&#xa;                        END - r.statement_start_offset)/2) + 1) &quot;StatementText&quot;,&#xa;  OBJECT_SCHEMA_NAME(tl.resource_associated_entity_id, tl.resource_database_id) &quot;ResourceSchema&quot;,&#xa;  OBJECT_NAME(tl.resource_associated_entity_id, tl.resource_database_id) &quot;ResourceObject&quot;,&#xa;  tl.resource_type &quot;ResourceType&quot;,&#xa;  tl.request_mode &quot;RequestMode&quot;,&#xa;  tl.request_status &quot;RequestStatus&quot;, &#xa;  tl.request_owner_type &quot;RequestOwnerType&quot;&#xa;FROM &#xa;  sys.dm_tran_locks as tl&#xa;INNER JOIN &#xa;  sys.dm_os_waiting_tasks as wt&#xa;ON &#xa;  tl.lock_owner_address = wt.resource_address&#xa;INNER JOIN &#xa;  sys.dm_exec_requests r on wt.session_id = r.session_id  &#xa;CROSS APPLY &#xa;  sys.dm_exec_sql_text(r.sql_handle) as st&#xa;ORDER BY &#xa;  wt.wait_duration_ms DESC;&#xa;" name="Blocked Sessions - Returns a list of sessions that are currently blocked (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns the top SQL statements in the procedure cache &#xa;-- Adjust the ORDER BY as needed (SQL Server 2005, 2008)&#xa;SELECT TOP 100&#xa;  total_worker_time/execution_count &quot;AvgCPU&quot;,&#xa;  total_elapsed_time/execution_count &quot;AvgDuration&quot;,&#xa;  (total_logical_reads + total_physical_reads)/execution_count &quot;AvgReads&quot;,&#xa;  execution_count &quot;ExecutionCount&quot;,&#xa;  SUBSTRING(st.text, (qs.statement_start_offset/2) + 1, &#xa;            ((CASE qs.statement_end_offset  &#xa;                WHEN -1 THEN datalength(st.text)  &#xa;                ELSE qs.statement_end_offset  &#xa;              END - qs.statement_start_offset)/2) + 1) &quot;StatementText&quot;,&#xa;  query_plan &quot;ExecutionPlan&quot;&#xa;FROM &#xa;  sys.dm_exec_query_stats as qs  &#xa;CROSS APPLY&#xa;  sys.dm_exec_sql_text(qs.sql_handle) as st  &#xa;CROSS APPLY&#xa;  sys.dm_exec_query_plan (qs.plan_handle) as qp &#xa;ORDER BY &#xa;  AvgCPU DESC;&#xa;" name="Queries in Procedure Cache - Returns the top SQL statements in the procedure cache (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns the SQL statements that are the top CPU consumers &#xa;-- (SQL Server 2005, 2008)&#xa;SELECT TOP 50&#xa;  CAST(qs.total_worker_time / execution_count / 1000.0 AS DECIMAL(20, 3)) &quot;AvgWorkerTime(ms)&quot;,&#xa;  substring(st.text, (qs.statement_start_offset/2) + 1, &#xa;            ((CASE qs.statement_end_offset&#xa;                WHEN -1 THEN datalength(st.text)&#xa;                ELSE qs.statement_end_offset&#xa;              END - qs.statement_start_offset)/2) + 1) &quot;StatementText&quot;,&#xa;  *&#xa;FROM&#xa;  sys.dm_exec_query_stats as qs&#xa;CROSS APPLY &#xa;  sys.dm_exec_sql_text(qs.sql_handle) as st&#xa;ORDER BY&#xa;  [AvgWorkerTime(ms)] DESC;&#xa;" name="Top SQL CPU Consumers - Returns the SQL statements that are the top CPU consumers (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns the SQL statements that are the top IO consumers &#xa;-- (SQL Server 2005, 2008)&#xa;SELECT TOP 50&#xa;  (total_logical_reads + total_logical_writes) as &quot;TotalLogicalIO&quot;, &#xa;  (total_logical_reads/execution_count) as &quot;AvgLogicalReads&quot;,&#xa;  (total_logical_writes/execution_count) as &quot;AvgLogicalWrites&quot;,&#xa;  (total_physical_reads/execution_count) as &quot;AvgPhysicalReads&quot;,&#xa;  substring(st.text, (qs.statement_start_offset/2) + 1, &#xa;            ((CASE qs.statement_end_offset&#xa;                WHEN -1 THEN datalength(st.text)&#xa;                ELSE qs.statement_end_offset&#xa;              END - qs.statement_start_offset)/2) + 1) as &quot;StatementText&quot;,&#xa;  *&#xa;FROM&#xa;  sys.dm_exec_query_stats as qs&#xa;CROSS APPLY&#xa;  sys.dm_exec_sql_text(qs.sql_handle) as st&#xa;ORDER BY&#xa;  TotalLogicalIO DESC;&#xa;" name="Top IO Consumers - Returns the SQL statements that are the top IO consumers (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns the SQL statements that have operations that potentially&#xa;-- read large numbers of rows (SQL Server 2005, 2008)&#xa;SELECT &#xa;  SUBSTRING(st.text, (qs.statement_start_offset/2) + 1, &#xa;            ((CASE qs.statement_end_offset  &#xa;                WHEN -1 THEN datalength(st.text)  &#xa;                ELSE qs.statement_end_offset  &#xa;              END - qs.statement_start_offset)/2) + 1) &quot;StatementText&quot;,&#xa;  qs.execution_count, &#xa;  qs.*, &#xa;  p.* &#xa;FROM&#xa;  sys.dm_exec_query_stats as qs &#xa;CROSS APPLY&#xa;  sys.dm_exec_sql_text(sql_handle) st&#xa;CROSS APPLY&#xa;  sys.dm_exec_query_plan(plan_handle) p&#xa;WHERE &#xa;  query_plan.exist('declare default element namespace &quot;http://schemas.microsoft.com/sqlserver/2004/07/showplan&quot;;&#xa;/ShowPlanXML/BatchSequence/Batch/Statements//RelOp/@EstimateRows[. > 10000]') = 1;&#xa;" name="SQL Workload High Rowcount - Returns the SQL statements that have operations that potentially read large numbers of rows (SQL Server 2005, 2008)" type="1"/>
                    </nodes>
                </node>
                <node name="Tables - Indexes" type="0">
                    <nodes>
                        <node code="-- Returns a list of indexes/heaps in the current database whose&#xa;-- fragementation level exceeds the provided threshold&#xa;-- and index size (SQL Server 2005, 2008)&#xa;SELECT&#xa;  SCHEMA_NAME(OBJECTPROPERTY(ps.object_id, 'SchemaId')) &quot;Schema&quot;,&#xa;  OBJECT_NAME(ps.object_id) &quot;ObjectName&quot;,&#xa;  si.name &quot;IndexName&quot;,&#xa;  ps.index_id &quot;IndexID&quot;,&#xa;  ps.index_type_desc &quot;IndexType&quot;,&#xa;  ps.partition_number &quot;Partition&quot;,&#xa;  ps.avg_fragmentation_in_percent &quot;Fragmentation(%)&quot;,&#xa;  ps.page_count &quot;PageCount&quot;&#xa;FROM &#xa;  sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, N'Limited') ps&#xa;INNER JOIN&#xa;  sys.indexes si&#xa;ON&#xa;  ps.object_id = si.object_id&#xa;AND&#xa;  ps.index_id = si.index_id&#xa;WHERE &#xa;  ps.avg_fragmentation_in_percent > $FragAmount$&#xa;AND&#xa;  ps.page_count > $PageCount$&#xa;ORDER BY&#xa;  [Fragmentation(%)] DESC;&#xa;" name="Index Fragmentation - Returns a list of indexes/heaps in the current database whose fragementation level exceeds the provided threshold and index size (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns a list of indexes in the current database &#xa;-- (SQL Server 2000)&#xa;SELECT &#xa;  USER_NAME(so.uid) &quot;Schema&quot;,&#xa;  so.name &quot;TableName&quot;,&#xa;  si.name &quot;IndexName&quot;,&#xa;  si.keycnt &quot;KeyCount&quot;,&#xa;  si.rows &quot;RowCount&quot;,&#xa;  CASE INDEXPROPERTY(si.id, si.name, 'IsClustered') &#xa;    WHEN 1 THEN 'Yes' &#xa;    ELSE 'No'  &#xa;  END &quot;Clustered&quot;,&#xa;  CASE INDEXPROPERTY(si.id, si.name, 'IsUnique') &#xa;    WHEN 1 THEN 'Yes' &#xa;    ELSE 'No' &#xa;  END &quot;Unique&quot;,&#xa;  STATS_DATE(si.id , si.indid) &quot;StatsUpdated&quot;&#xa;FROM &#xa;  sysindexes AS si&#xa;INNER JOIN &#xa;  sysobjects so&#xa;on &#xa;  si.id = so.id&#xa;WHERE &#xa;  OBJECTPROPERTY(si.id, 'IsMSShipped') = 0 &#xa;AND&#xa;  INDEXPROPERTY(si.id, si.name ,'IsStatistics') = 0 &#xa;AND&#xa;  INDEXPROPERTY(si.id, si.name, 'IsAutoStatistics') = 0 &#xa;AND&#xa;  INDEXPROPERTY(si.id, si.name, 'IsHypothetical') = 0 &#xa;AND&#xa;  si.indid BETWEEN 1 AND 254&#xa;ORDER BY &#xa;  [Schema],&#xa;  TableName, &#xa;  IndexName;&#xa;" name="Index List (2000) - Returns a list of indexes in the current database (SQL Server 2000)" type="1"/>
                        <node code="-- Returns a list of indexes in the current database &#xa;-- (SQL Server 2005, 2008)&#xa;SELECT &#xa;  SCHEMA_NAME(so.schema_id) &quot;Schema&quot;,&#xa;  so.name &quot;TableName&quot;,&#xa;  si.name &quot;IndexName&quot;,&#xa;  CASE INDEXPROPERTY(si.object_id, si.name, 'IsClustered') &#xa;    WHEN 1 THEN 'Yes' &#xa;    ELSE 'No'  &#xa;  END &quot;Clustered&quot;,&#xa;  CASE INDEXPROPERTY(si.object_id, si.name, 'IsUnique') &#xa;    WHEN 1 THEN 'Yes' &#xa;    ELSE 'No' &#xa;  END &quot;Unique&quot;,&#xa;  STATS_DATE(si.object_id , si.index_id) &quot;StatsUpdated&quot;&#xa;FROM &#xa;  sys.indexes AS si&#xa;INNER JOIN &#xa;  sys.objects so&#xa;on &#xa;  si.object_id = so.object_id&#xa;WHERE &#xa;  OBJECTPROPERTY(si.object_id, 'IsMSShipped') = 0 &#xa;AND&#xa;  INDEXPROPERTY(si.object_id, si.name ,'IsStatistics') = 0 &#xa;AND&#xa;  INDEXPROPERTY(si.object_id, si.name, 'IsAutoStatistics') = 0 &#xa;AND&#xa;  INDEXPROPERTY(si.object_id, si.name, 'IsHypothetical') = 0 &#xa;AND&#xa;  si.index_id > 0&#xa;ORDER BY &#xa;  [Schema],&#xa;  TableName, &#xa;  IndexName;&#xa;" name="Index List - Returns a list of indexes in the current database (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns a list of missing indexes that SQL Server believes (if added)&#xa;-- would result in the highest anticipated cumulative improvement&#xa;-- based on query execution since the last restart &#xa;-- (SQL Server 2005, 2008)&#xa;SELECT&#xa;  CAST((migs.avg_total_user_cost * migs.avg_user_impact) * &#xa;    (migs.user_seeks + migs.user_scans) AS DECIMAL(20,3)) &quot;ImpactFactor&quot;,&#xa;  statement &quot;Table&quot;,&#xa;  N'CREATE NONCLUSTERED INDEX ix_' +&#xa;    sys.objects.name COLLATE DATABASE_DEFAULT + '_' +&#xa;    REPLACE(REPLACE(REPLACE(ISNULL(mid.equality_columns,'') +&#xa;      ISNULL(mid.inequality_columns,''), '[', ''), ']',''), ', ','_') + &#xa;    ' ON ' + [statement] + ' ( ' + IsNull(mid.equality_columns, '') +&#xa;    CASE &#xa;      WHEN mid.inequality_columns IS NULL THEN '' &#xa;      ELSE&#xa;        CASE &#xa;          WHEN mid.equality_columns IS NULL THEN '' &#xa;          ELSE ',' &#xa;        END + mid.inequality_columns &#xa;    END + ' ) ' + &#xa;    CASE &#xa;      WHEN mid.included_columns IS NULL THEN '' &#xa;      ELSE 'INCLUDE (' + mid.included_columns + ')' &#xa;    END + ';' &quot;CreateIndexStatement&quot;,&#xa;  migs.avg_user_impact &quot;UserImprovement(%)&quot;,&#xa;  migs.avg_system_impact &quot;SystemImprovement(%)&quot;,&#xa;  migs.user_scans &quot;UserScans&quot;,&#xa;  migs.system_scans &quot;SystemScans&quot;,&#xa;  migs.user_seeks &quot;UserSeeks&quot;,&#xa;  migs.system_seeks &quot;SystemSeeks&quot;,&#xa;  mid.equality_columns &quot;EqualityColumns&quot;,&#xa;  mid.inequality_columns &quot;InequalityColumns&quot;,&#xa;  mid.included_columns &quot;IncludedColumns&quot;&#xa;FROM &#xa;  sys.dm_db_missing_index_group_stats migs&#xa;INNER JOIN &#xa;  sys.dm_db_missing_index_groups mig &#xa;ON &#xa;  migs.group_handle = mig.index_group_handle&#xa;INNER JOIN &#xa;  sys.dm_db_missing_index_details mid &#xa;ON &#xa;  mig.index_handle = mid.index_handle&#xa;INNER JOIN &#xa;  sys.objects WITH (nolock) &#xa;ON &#xa;  mid.OBJECT_ID = sys.objects.OBJECT_ID&#xa;WHERE (&#xa;  migs.group_handle IN (&#xa;    SELECT TOP (500) group_handle&#xa;    FROM sys.dm_db_missing_index_group_stats WITH (nolock)&#xa;    ORDER BY (avg_total_user_cost * avg_user_impact) * (user_seeks + user_scans) DESC))&#xa;AND &#xa;  OBJECTPROPERTY(sys.objects.OBJECT_ID, 'isusertable') = 1&#xa;ORDER BY &#xa;  ImpactFactor DESC, &#xa;  CreateIndexStatement DESC;&#xa;" name="Missing Indexes - Returns a list of missing indexes that SQL Server believes (if added) would result in the highest anticipated cumulative improvement on (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns a list of indexes in the current database whose statistics &#xa;-- have not been updated in the specified number of days &#xa;-- (SQL Server 2000)&#xa;SELECT &#xa;  USER_NAME(so.uid) &quot;Owner&quot;,&#xa;  OBJECT_NAME(si.id) &quot;ObjectName&quot;,&#xa;  si.name &quot;IndexName&quot;, &#xa;  STATS_DATE(si.id, si.indid) &quot;StatisticsDate&quot;&#xa;FROM &#xa;  sysindexes si&#xa;INNER JOIN&#xa;  sysobjects so&#xa;ON&#xa;  si.id = so.id&#xa;WHERE &#xa;  DATEDIFF(d, STATS_DATE(si.id, si.indid), GETDATE()) > $NumDays$&#xa;ORDER BY&#xa;  [StatisticsDate];&#xa;" name="Out of Date Statistics (2000) - Returns a list of indexes in the current database whose statistics have not been updated in the specified number of days (SQL Server 2000)" type="1"/>
                        <node code="-- Returns a list of indexes in the current database over the specified size&#xa;-- whose statistics have not been updated in the specified number of days &#xa;-- (SQL Server 2005, 2008)&#xa;SELECT &#xa;  SCHEMA_NAME(OBJECTPROPERTY(si.object_id, 'SchemaId')) &quot;Schema&quot;,&#xa;  OBJECT_NAME(si.object_id) &quot;ObjectName&quot;,&#xa;  si.name &quot;IndexName&quot;, &#xa;  STATS_DATE(si.object_id, si.index_id) &quot;StatisticsDate&quot;,&#xa;  ps.page_count &quot;PageCount&quot;&#xa;FROM &#xa;  sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, N'Limited') ps&#xa;INNER JOIN&#xa;  sys.indexes si&#xa;ON&#xa;  ps.object_id = si.object_id&#xa;AND&#xa;  ps.index_id = si.index_id&#xa;WHERE &#xa;  ps.page_count > $PageCount$&#xa;AND&#xa;  DATEDIFF(d, STATS_DATE(si.object_id, si.index_id), GETDATE()) > $NumDays$&#xa;ORDER BY&#xa;  [StatisticsDate];&#xa;" name="Out of Date Statistics - Returns a list of indexes in the current database over the specified size whose statistics have not been updated in the specified number of days (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns the size of each index/heap in the current database&#xa;-- (SQL Server 2005, 2008)&#xa;SELECT &#xa;  SCHEMA_NAME(so.schema_id) &quot;Schema&quot;,&#xa;  OBJECT_NAME(ips.[object_id]) &quot;TableName&quot;,&#xa;  ips.index_id &quot;IndexID&quot;,&#xa;  ISNULL(si.name, OBJECT_NAME(ips.[object_id])) &quot;IndexName&quot;,&#xa;  ips.index_type_desc &quot;IndexType&quot;,&#xa;  CAST(sum(ips.page_count)*1.0/128 AS DECIMAL(15, 2)) &quot;Size (MB)&quot;,&#xa;  SUM(ips.page_count) &quot;PageCount&quot;,&#xa;  SUM(ips.record_count) &quot;RowCount&quot;&#xa;FROM &#xa;  sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'SAMPLED') AS ips&#xa;INNER JOIN &#xa;  sys.indexes AS si&#xa;ON &#xa;  ips.object_id = si.object_id &#xa;AND &#xa;  ips.index_id = si.index_id&#xa;INNER JOIN &#xa;  sys.objects so&#xa;ON&#xa;  si.[object_id] = so.[object_id]&#xa;GROUP BY&#xa;  so.schema_id,&#xa;  ips.object_id,&#xa;  ips.index_id, &#xa;  si.name,&#xa;  ips.index_type_desc&#xa;ORDER BY&#xa;  PageCount DESC;&#xa;" name="Index Sizes - Returns the size of each index/heap in the current database on SQL Server 2005, 2008" type="1"/>
                        <node code="-- Returns all indexes that have not been used in the current&#xa;-- database since SQL Server was last started &#xa;-- (SQL Server 2005, 2008)&#xa;SELECT &#xa;  SCHEMA_NAME(OBJECTPROPERTY(object_id, 'SchemaId')) &quot;Schema&quot;,&#xa;  object_name(object_id) &quot;ObjectName&quot;, &#xa;  i.name &quot;IndexName&quot;&#xa;FROM&#xa;  sys.indexes i &#xa;WHERE&#xa;  i.index_id NOT IN (&#xa;    SELECT s.index_id &#xa;    FROM sys.dm_db_index_usage_stats s &#xa;    WHERE s.object_id=i.object_id &#xa;    AND i.index_id=s.index_id &#xa;    AND database_id = DB_ID() )&#xa;AND&#xa;  SCHEMA_NAME(OBJECTPROPERTY(object_id, 'SchemaId')) != N'sys'&#xa;ORDER BY&#xa;  [Schema],&#xa;  [ObjectName];&#xa;GO&#xa;" name="Unused Indexes - Returns all indexes that have not been used in the current database since SQL Server was last started (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Estimates the size of a table if compression were enabled &#xa;-- (SQL Server 2008)&#xa;CREATE TABLE #Compression (&#xa;  [ObjectName] sysname,&#xa;  [SchemaName] sysname,&#xa;  [IndexID] int,&#xa;  [PartitionNumber] int,&#xa;  [SizeCurrentCompressionSetting(KB)] bigint,&#xa;  [SizeRequestedCompressionSetting(KB)] bigint,&#xa;  [SampleSizeCurrentCompressionSetting(KB)] bigint,&#xa;  [SampleSizeRequestedCompressionSetting(KB)] bigint );&#xa;  &#xa;INSERT INTO #Compression&#xa;EXEC sp_estimate_data_compression_savings &#xa;  @schema_name = N'$SchemaName$',&#xa;  @object_name = N'$TableName$',&#xa;  @index_id = NULL,&#xa;  @partition_number = NULL,&#xa;  @data_compression = '$CompressionType$' -- NONE, ROW, PAGE&#xa;&#xa;SELECT&#xa;  ObjectName,&#xa;  SchemaName,&#xa;  SUM(c.[SizeCurrentCompressionSetting(KB)]) &quot;SizeCurrentCompressionSetting(KB)&quot;,&#xa;  SUM(c.[SizeRequestedCompressionSetting(KB)]) &quot;SizeRequestedCompressionSetting(KB)]&quot;,&#xa;  CAST((1.00 - (SUM(c.[SizeRequestedCompressionSetting(KB)]) * 1.00) / &#xa;    (SUM(c.[SizeCurrentCompressionSetting(KB)]) * 1.00)) * 100 AS DECIMAL(10, 2)) &quot;Savings(%)&quot;,&#xa;  SUM(c.[SampleSizeCurrentCompressionSetting(KB)]) &quot;SampleSizeCurrentCompressionSetting(KB)&quot;,&#xa;  SUM(c.[SampleSizeRequestedCompressionSetting(KB)]) &quot;SampleSizeRequestedCompressionSetting(KB)&quot;,&#xa;  CAST((1.00 - (SUM(c.[SampleSizeRequestedCompressionSetting(KB)]) * 1.00) / &#xa;    (SUM(c.[SampleSizeCurrentCompressionSetting(KB)]) * 1.00)) * 100 AS DECIMAL(10, 2)) &quot;SampleSavings(%)&quot;&#xa;FROM&#xa;  #Compression c&#xa;GROUP BY&#xa;  ObjectName,&#xa;  SchemaName;&#xa;&#xa;SELECT * FROM #Compression;&#xa;&#xa;DROP TABLE #Compression;&#xa;" name="Estimate Table Data Compression - Estimates the size of a table if compression were enabled (SQL Server 2008)" type="1"/>
                        <node code="-- Returns a list of tables in the current database that&#xa;-- do not contain any indexes (SQL Server 2000)&#xa;SELECT &#xa;  USER_NAME(uid) &quot;Owner&quot;,&#xa;  name &quot;TableName&quot;&#xa;FROM &#xa;  sysobjects &#xa;WHERE &#xa;  OBJECTPROPERTY(id, 'IsIndexed') = 0&#xa;AND &#xa;  OBJECTPROPERTY(id, 'IsUserTable') = 1&#xa;ORDER BY&#xa;  [Owner],&#xa;  [TableName];&#xa;" name="Tables No Indexes (2000) - Returns a list of tables in the current database that do not contain any indexes (SQL Server 2000)" type="1"/>
                        <node code="-- Returns a list of user tables in the current database that&#xa;-- do not contain any indexes (SQL Server 2005, 2008)&#xa;SELECT &#xa;  SCHEMA_NAME(OBJECTPROPERTY(object_id, 'SchemaId')) &quot;Schema&quot;,&#xa;  name &quot;TableName&quot;&#xa;FROM &#xa;  sys.tables &#xa;WHERE &#xa;  OBJECTPROPERTY(object_id, 'IsIndexed') = 0&#xa;AND&#xa;  OBJECTPROPERTY(object_id, 'IsUserTable') = 1&#xa;ORDER BY&#xa;  [Schema],&#xa;  [TableName];&#xa;" name="Tables No Indexes - Returns a list of user tables in the current database that do not contain any indexes (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns a list of tables that do not have primary keys defined&#xa;-- (SQL Server 2000)&#xa;SELECT &#xa;  USER_NAME(OBJECTPROPERTY(id, 'OwnerId')) &quot;Schema&quot;,&#xa;  [name] &quot;TableName&quot;&#xa;FROM &#xa;  sysobjects WITH (NOLOCK)&#xa;WHERE &#xa;  OBJECTPROPERTY(id,'TableHasPrimaryKey') = 0&#xa;AND&#xa;  OBJECTPROPERTY(id,'IsMSShipped') = 0  &#xa;AND &#xa;  [type] = 'U' &#xa;ORDER BY &#xa;  [Schema], &#xa;  [TableName];&#xa;" name="Tables No Primary Key (2000) - Returns a list of tables that do not have primary keys defined (SQL Server 2000)" type="1"/>
                        <node code="-- Returns a list of tables that do not have primary keys defined&#xa;-- (SQL Server 2005, 2008)&#xa;SELECT &#xa;  OBJECT_SCHEMA_NAME(object_id) &quot;Schema&quot;,&#xa;  [name] &quot;TableName&quot;&#xa;FROM &#xa;  sys.objects WITH (NOLOCK)&#xa;WHERE &#xa;  OBJECTPROPERTY(object_id,'TableHasPrimaryKey') = 0&#xa;AND&#xa;  OBJECTPROPERTY(object_id,'IsMSShipped') = 0  &#xa;AND &#xa;  [type] = 'U' &#xa;ORDER BY &#xa;  [Schema], &#xa;  [TableName];&#xa;&#xa;" name="Tables No Primary Key - Returns a list of tables that do not have primary keys defined (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns a list of tables with corresponding row counts and space information&#xa;-- (SQL Server 2005, 2008)&#xa;SET NOCOUNT ON;&#xa;DECLARE @TableName  NVARCHAR(256);&#xa;DECLARE @SchemaName NVARCHAR(256);&#xa; &#xa;CREATE TABLE #TableList (&#xa;  [ID] INT IDENTITY,&#xa;  [TableName] NVARCHAR(128),&#xa;  [RowCount] CHAR(11),&#xa;  [KBReserved] VARCHAR(15),&#xa;  [KBData] VARCHAR(18),&#xa;  [KBIndex] VARCHAR(18),&#xa;  [KBUnused] VARCHAR(18) );&#xa;&#xa;CREATE TABLE #ObjectSchema (&#xa;  [ID] INT,&#xa;  [SchemaName] NVARCHAR(128));&#xa;CREATE UNIQUE INDEX ObjectSchemaID on #ObjectSchema(ID);&#xa;&#xa;-- Run a cursor through all of the tables&#xa;DECLARE ObjectListCursor CURSOR FAST_FORWARD FOR &#xa;SELECT schema_name(schema_id), QUOTENAME(schema_name(schema_id)) + N'.' + QUOTENAME(name)&#xa;FROM sys.objects &#xa;WHERE type = 'U';&#xa; &#xa;OPEN ObjectListCursor&#xa;FETCH NEXT FROM ObjectListCursor INTO @SchemaName, @TableName&#xa;WHILE @@FETCH_STATUS = 0&#xa;BEGIN &#xa;  INSERT INTO #TableList&#xa;  EXEC dbo.sp_spaceused @TableName&#xa;  IF SCOPE_IDENTITY() IS NOT NULL&#xa;    INSERT #ObjectSchema VALUES (SCOPE_IDENTITY(), @SchemaName)&#xa;FETCH NEXT FROM ObjectListCursor INTO @SchemaName, @TableName&#xa;END&#xa;&#xa;CLOSE ObjectListCursor;&#xa;DEALLOCATE ObjectListCursor;&#xa; &#xa;UPDATE &#xa;  #TableList&#xa;SET &#xa;  KBReserved = REPLACE(KBReserved, ' KB', ''),&#xa;  KBData = REPLACE(KBData, ' KB', ''),&#xa;  KBIndex = REPLACE(KBIndex, ' KB', ''),&#xa;  KBUnused = REPLACE(KBUnused, ' KB', '');&#xa; &#xa;SELECT &#xa;  b.[SchemaName], &#xa;  a.[TableName], &#xa;  CAST(a.[RowCount] AS BIGINT) &quot;RowCount&quot;, &#xa;  CAST(a.[KBReserved] AS BIGINT) &quot;Reserved(KB)&quot;, &#xa;  CAST(a.[KBData] AS BIGINT) &quot;Data(KB)&quot;, &#xa;  CAST(a.[KBIndex] AS BIGINT) &quot;Index(KB)&quot;, &#xa;  CAST(a.[KBUnused] AS BIGINT) &quot;Unused(KB)&quot;&#xa;FROM &#xa;  #TableList a&#xa;INNER JOIN&#xa;  #ObjectSchema b&#xa;ON&#xa;  a.ID = b.ID&#xa;ORDER BY &#xa;  b.SchemaName, a.TableName;&#xa;  &#xa;DROP TABLE #TableList;&#xa;DROP TABLE #ObjectSchema;&#xa;" name="Table Sizes - Returns a list of tables with corresponding row counts and space information (SQL Server 2005, 2008)" type="1"/>
                    </nodes>
                </node>
                <node name="Trace" type="0">
                    <nodes>
                        <node code="-- Displays a list of active traces &#xa;-- (SQL Server 2000)&#xa;SELECT &#xa;  traceid &quot;TraceID&quot;,&#xa;  CASE property&#xa;    WHEN 1 THEN&#xa;      'TraceOptions'&#xa;    WHEN 2 THEN&#xa;      'FileName'&#xa;    WHEN 3 THEN&#xa;      'MaxSize'&#xa;    WHEN 4 THEN&#xa;      'StopTime'&#xa;    WHEN 5 THEN&#xa;      'TraceStatus'&#xa;  END &quot;PropertyName&quot;,&#xa;  property as &quot;Property&quot;,&#xa;  CASE property&#xa;    WHEN 5 THEN&#xa;      CASE value&#xa;        WHEN 0 THEN&#xa;          '0 - Stopped'&#xa;        WHEN 1 THEN&#xa;          '1 - Started'&#xa;        WHEN 2 THEN&#xa;          '2 - Closed'&#xa;      END&#xa;    ELSE&#xa;     value&#xa;  END AS &quot;Value&quot;&#xa;FROM&#xa;  ::fn_trace_getinfo(Default)&#xa;ORDER BY&#xa;  TraceID,&#xa;  Property;&#xa;" name="Active Traces (2000) - Displays a list of active traces (SQL Server 2000)" type="1"/>
                        <node code="-- Displays a list of active traces &#xa;-- (SQL Server 2005/2008)&#xa;SELECT &#xa;  CASE status &#xa;    WHEN 0 THEN&#xa;      'Stopped'&#xa;    WHEN 1 THEN&#xa;      'Started'&#xa;  END AS &quot;Status&quot;,&#xa;  * &#xa;FROM&#xa;  sys.traces;&#xa;" name="Active Traces - Displays a list of active traces for SQL Server (SQL Server 2005, 2008)" type="1"/>
                        <node
                            code="-- Starts a SQL Server Trace for Benchmark Factory for SQL Server 2005+&#xa;-- Please modify the sections below as needed before executing&#xa;&#xa;SET NOCOUNT ON;&#xa;&#xa;DECLARE @rc                   INT;&#xa;DECLARE @TraceID              INT;&#xa;DECLARE @MaxFileSize          BIGINT;&#xa;DECLARE @DateTime             DATETIME;&#xa;DECLARE @TraceFile            NVARCHAR(245);&#xa;DECLARE @DestinationTableName NVARCHAR(128);&#xa;&#xa;-- Trace File Name - Should be local to SQL Server instance (unique name generated)&#xa;SET @TraceFile = N'$TraceFolder$\BMFTrace' + N'-' + CAST(NEWID() AS NVARCHAR(100))&#xa;&#xa;-- The destination table name - database qualified - table must not exist&#xa;SET @DestinationTableName = N'[$DestinationDB$].[dbo].[BMFWorkload' + N'-' + CONVERT(NVARCHAR(20), getdate(), 112) + N'-' + LEFT(CAST(NEWID() AS NVARCHAR(100)), 8) + N']'&#xa;&#xa;-- Trace End Date/Time - Uncomment and change date/time as needed&#xa;-- SET @DateTime = '2009-05-14 14:00:00.000'&#xa;&#xa;-- The Maximum Trace File Size in MB before rollover&#xa;SET @MaxFileSize = 10;&#xa;&#xa;-- Create the trace&#xa;-- Change the output folder as needed (this folder should be local to the SQL Server instance&#xa;EXEC @rc = sp_trace_create&#xa;  @TraceID output, -- The TraceID of the trace&#xa;  2, -- Use a Rollover trace&#xa;  @TraceFile,&#xa;  @MaxFileSize,&#xa;  @DateTime&#xa;IF (@rc != 0) GOTO error&#xa;&#xa;-- Bind the events for the trace&#xa;DECLARE @on bit&#xa;SET @on = 1&#xa;-- 11 = RPC:Starting&#xa;EXEC sp_trace_setevent @TraceID, 11, 1,  @on -- TextData&#xa;EXEC sp_trace_setevent @TraceID, 11, 9,  @on -- ClientProcessID&#xa;EXEC sp_trace_setevent @TraceID, 11, 6,  @on -- NTUserName&#xa;EXEC sp_trace_setevent @TraceID, 11, 10, @on -- ApplicationName&#xa;EXEC sp_trace_setevent @TraceID, 11, 14, @on -- StartTime&#xa;EXEC sp_trace_setevent @TraceID, 11, 11, @on -- LoginName&#xa;EXEC sp_trace_setevent @TraceID, 11, 12, @on -- SPID&#xa;EXEC sp_trace_setevent @TraceID, 11, 13, @on -- Duration&#xa;EXEC sp_trace_setevent @TraceID, 11, 35, @on -- DatabaseName&#xa;-- 13 = SQL:BatchStarting&#xa;EXEC sp_trace_setevent @TraceID, 13, 12, @on -- SPID&#xa;EXEC sp_trace_setevent @TraceID, 13, 1,  @on -- TextData&#xa;EXEC sp_trace_setevent @TraceID, 13, 9,  @on -- ClientProcessID&#xa;EXEC sp_trace_setevent @TraceID, 13, 6,  @on -- NTUserName&#xa;EXEC sp_trace_setevent @TraceID, 13, 10, @on -- ApplicationName&#xa;EXEC sp_trace_setevent @TraceID, 13, 14, @on -- StartTime&#xa;EXEC sp_trace_setevent @TraceID, 13, 11, @on -- LoginName&#xa;EXEC sp_trace_setevent @TraceID, 13, 13, @on -- Duration&#xa;EXEC sp_trace_setevent @TraceID, 13, 35, @on -- DatabaseName&#xa;&#xa;-- Set the Filters&#xa;-- If you need any filters for the trace, then you can uncomment the appropriate section below&#xa;DECLARE @intfilter    INT;&#xa;DECLARE @bigintfilter BIGINT;&#xa;&#xa;-- LIKE NTUserName Filter&#xa;/*&#xa;-- Use this sp_trace_setfilter syntax for the first LIKE NTUserName filtered item&#xa;EXEC sp_trace_setfilter @TraceID, 6, 0, 6, N'LIKE NTUserName1'&#xa;-- Use this sp_trace_setfilter syntax for any further LIKE NTUserName items&#xa;EXEC sp_trace_setfilter @TraceID, 6, 1, 6, N'LIKE NTUserName2'&#xa;*/&#xa;&#xa;-- NOT LIKE NTUserName Filter&#xa;/*&#xa;-- Use this sp_trace_setfilter syntax for the first NOT LIKE NTUserName filtered item&#xa;EXEC sp_trace_setfilter @TraceID, 6, 0, 7, N'NOT LIKE NTUserName1'&#xa;-- Use this sp_trace_setfilter syntax for any further NOT LIKE NTUserName items&#xa;EXEC sp_trace_setfilter @TraceID, 6, 0, 7, N'NOT LIKE NTUserName2'&#xa;*/&#xa;&#xa;-- LIKE ApplicationName Filter&#xa;/*&#xa;-- Use this sp_trace_setfilter syntax for the first LIKE ApplicationName filtered item&#xa;EXEC sp_trace_setfilter @TraceID, 10, 0, 6, N'LIKE Application1'&#xa;-- Use this sp_trace_setfilter syntax for any further LIKE ApplicationName items&#xa;EXEC sp_trace_setfilter @TraceID, 10, 1, 6, N'LIKE Application2'&#xa;*/&#xa;&#xa;-- NOT LIKE ApplicationName Filter&#xa;/*&#xa;-- Use this sp_trace_setfilter syntax for the first NOT LIKE ApplicationName filtered item&#xa;EXEC sp_trace_setfilter @TraceID, 10, 0, 7, N'NOT LIKE Application1'&#xa;-- Use this sp_trace_setfilter syntax for any further NOT LIKE ApplicationName items&#xa;EXEC sp_trace_setfilter @TraceID, 10, 0, 7, N'NOT LIKE Application2'&#xa;*/&#xa;&#xa;-- LIKE LoginName Filter&#xa;/*&#xa;-- Use this sp_trace_setfilter syntax for the first LIKE LoginName filtered item&#xa;EXEC sp_trace_setfilter @TraceID, 11, 0, 6, N'LIKE LoginName1'&#xa;-- Use this sp_trace_setfilter syntax for any further LIKE LoginName items&#xa;EXEC sp_trace_setfilter @TraceID, 11, 1, 6, N'LIKE LoginName2'&#xa;*/&#xa;&#xa;-- NOT LIKE LoginName Filter&#xa;/*&#xa;-- Use this sp_trace_setfilter syntax for the first NOT LIKE LoginName filtered item&#xa;EXEC sp_trace_setfilter @TraceID, 11, 0, 7, N'NOT LIKE LoginName1'&#xa;-- Use this sp_trace_setfilter syntax for any further NOT LIKE LoginName items&#xa;EXEC sp_trace_setfilter @TraceID, 11, 0, 7, N'NOT LIKE LoginName2'&#xa;*/&#xa;&#xa;-- LIKE DatabaseName Filter&#xa;/*&#xa;-- Use this sp_trace_setfilter syntax for the first LIKE DatabaseName filtered item&#xa;EXEC sp_trace_setfilter @TraceID, 35, 0, 6, N'LIKE DatabaseName1'&#xa;-- Use this sp_trace_setfilter syntax for any further LIKE DatabaseName items&#xa;EXEC sp_trace_setfilter @TraceID, 35, 1, 6, N'LIKE DatabaseName2'&#xa;*/&#xa;&#xa;-- NOT LIKE DatabaseName Filter&#xa;/*&#xa;-- Use this sp_trace_setfilter syntax for the first NOT LIKE DatabaseName filtered item&#xa;EXEC sp_trace_setfilter @TraceID, 35, 0, 7, N'NOT LIKE DatabaseName1'&#xa;-- Use this sp_trace_setfilter syntax for any further NOT LIKE DatabaseName items&#xa;EXEC sp_trace_setfilter @TraceID, 35, 0, 7, N'NOT LIKE DatabaseName2'&#xa;*/&#xa;&#xa;-- Start the Trace&#xa;EXEC sp_trace_setstatus @TraceID, 1&#xa;&#xa;-- Select the TraceID&#xa;SELECT&#xa;  @TraceID &quot;TraceID&quot;,&#xa;  'Use this TraceID to Pause or Stop the trace with the Change Trace Status Code Snippet or use the following T-SQL statements to stop and migrate the data to a database' &quot;Instructions&quot;&#xa;&#xa;SELECT&#xa;  1 &quot;Step&quot;,&#xa;  'Stop Trace' &quot;Description&quot;,&#xa;  N'Exec sp_trace_setstatus ' + CAST(@TraceID AS NVARCHAR(5)) + N', 0' &quot;Command&quot;&#xa;UNION ALL&#xa;SELECT&#xa;  2 &quot;Step&quot;,&#xa;  'Delete Trace Definition' &quot;Description&quot;,&#xa;  N'Exec sp_trace_setstatus ' + CAST(@TraceID AS NVARCHAR(5)) + N', 2' &quot;Command&quot;&#xa;UNION ALL&#xa;SELECT&#xa;  3 &quot;Step&quot;,&#xa;  'Insert Data Into Database' &quot;Description&quot;,&#xa;  N'SELECT&#xa;      IDENTITY(int, 1, 1) &quot;RowNumber&quot;,&#xa;      [EventClass],&#xa;      [TextData],&#xa;      [NTUserName],&#xa;      [ApplicationName],&#xa;      [StartTime],&#xa;      [LoginName],&#xa;      [SPID],&#xa;      [Duration],&#xa;      [ClientProcessID],&#xa;      [DatabaseName]&#xa;    INTO ' + @DestinationTableName + N'&#xa;    From ::fn_trace_gettable(''' + @TraceFile + N'.trc'', default) OPTION (MAXDOP 1)' &quot;Command&quot;&#xa;UNION ALL&#xa;SELECT&#xa;  4 &quot;Step&quot;,&#xa;  'Delete Trace File (manual process if xp_cmdshell is disabled)' &quot;Description&quot;,&#xa;  N'Exec master..xp_cmdshell &quot;DEL &quot;&quot;' + @TraceFile  + N'*.trc&quot;&quot;&quot;, no_output'&#xa;ORDER BY 1;&#xa;&#xa;GOTO finish;&#xa;&#xa;error:&#xa;SELECT @rc &quot;ErrorCode&quot;&#xa;&#xa;finish:&#xa;"
                            name="Benchmark Factory Trace - Starts a trace suitable for scalability testing in Benchmark Factory" type="1"/>
                        <node code="-- Displays a list of bound events for the specified trace &#xa;-- (SQL Server 2005, 2008)&#xa;-- To see a list of running traces, execute:&#xa;-- SELECT * from sys.traces&#xa;WITH Events (eventid)&#xa;AS (&#xa;  SELECT DISTINCT eventid from fn_trace_geteventinfo($TraceID$))&#xa;SELECT &#xa;  cat.name AS CategoryName, &#xa;  te.name  AS EventName&#xa;FROM &#xa;  Events&#xa;INNER JOIN &#xa;  sys.trace_events AS te&#xa;ON &#xa;  Events.eventid = te.trace_event_id&#xa;INNER JOIN &#xa;  sys.trace_categories AS cat&#xa;ON &#xa;  te.category_id = cat.category_id&#xa;ORDER BY &#xa;  CategoryName, &#xa;  EventName;&#xa;  " name="Bound Trace Events - Displays a list of bound events for the specified trace (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Displays a list of bound events and columns for the specified trace &#xa;-- (SQL Server 2005, 2008)&#xa;-- To see a list of running traces, execute:&#xa;-- SELECT * from sys.traces&#xa;WITH Events (eventid, columnid)&#xa;AS (&#xa;  SELECT DISTINCT eventid, columnid from fn_trace_geteventinfo($TraceID$))&#xa;SELECT &#xa;  cat.name        AS CategoryName, &#xa;  Events.eventid  AS EventID,&#xa;  te.name         AS EventName,&#xa;  Events.columnid AS ColumnID,&#xa;  col.name        AS ColumnName&#xa;FROM &#xa;  Events&#xa;INNER JOIN &#xa;  sys.trace_events AS te&#xa;ON &#xa;  Events.eventid = te.trace_event_id&#xa;INNER JOIN &#xa;  sys.trace_categories AS cat&#xa;ON &#xa;  te.category_id = cat.category_id&#xa;INNER JOIN&#xa;  sys.trace_columns AS col&#xa;ON&#xa;  Events.columnid = col.trace_column_id&#xa;ORDER BY &#xa;  CategoryName, &#xa;  EventName,&#xa;  ColumnName;&#xa;  " name="Bound Events - Columns for a Trace - Displays a list of bound events and columns for the specified trace (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Changes the status of a trace&#xa;-- 0-Pause, 1-Start, 2-Stop/Delete&#xa;-- Note: Profiler traces can be paused, but then they are automatically stopped by the Profiler client&#xa;DECLARE @TraceID    int;&#xa;DECLARE @NewStatus  int;&#xa;&#xa;SET @TraceID = $TraceID$ -- TraceID;&#xa;SET @NewStatus = $TraceStatus$ --NewStatus;&#xa;&#xa;-- Make sure we have a valid trace handle&#xa;If Not Exists (&#xa; Select 0&#xa; From   ::fn_trace_getinfo(default)&#xa; Where  traceid = @TraceID )&#xa;Begin&#xa; Raiserror ('The trace status could not be changed because the trace id provided is not valid', 16, 1)&#xa; Goto Complete&#xa;End&#xa;&#xa;If @NewStatus = 2 -- Stop/Delete&#xa;Begin&#xa;  -- First Stop&#xa;  Exec sp_trace_setstatus @TraceID, 0&#xa;  If (@@error != 0)&#xa;    Goto Error&#xa;&#xa;  -- Then Delete&#xa;  Exec sp_trace_setstatus @TraceID, 2&#xa;  If (@@error != 0)&#xa;    Goto Error&#xa;End&#xa;Else&#xa;Begin&#xa;  -- Set the new status&#xa;  Exec sp_trace_setstatus @TraceID, @NewStatus&#xa;  If (@@error != 0)&#xa;    Goto Error&#xa;End&#xa;Goto Complete&#xa;&#xa;Error:&#xa;  Raiserror ('The trace status could not be changed', 16, 1)&#xa;&#xa;Complete:&#xa;  -- All done&#xa;  " name="Change Trace Status - Pauses, Starts, or Stops a trace" type="1"/>
                        <node code="-- Check if the Default Trace is enabled &#xa;-- (SQL Server 2005, 2008)&#xa;IF (&#xa;  SELECT &#xa;    COUNT(*)&#xa;  FROM &#xa;    sys.traces &#xa;  WHERE&#xa;    is_default = 1) > 0&#xa;  PRINT 'Default Trace is Enabled'&#xa;ELSE&#xa;  PRINT 'Default Trace is Not Enabled';&#xa;  " name="Default Trace Check - Checks to see if the Default Trace is running on the instance (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Enables or Disables the SQL Server Default Trace &#xa;-- (SQL Server 2005, 2008)&#xa;DECLARE @AdvancedOptions BIT;&#xa;DECLARE @DefaultTrace    BIT;&#xa;DECLARE @Enable          BIT;&#xa;&#xa;-- Set the variable to enable (1) or disable (0) the default trace&#xa;SET @Enable = $EnableDefaultTrace$;&#xa;&#xa;-- Temp table for Show Advanced Options setting&#xa;CREATE TABLE #Options (&#xa;  name         VARCHAR(30),&#xa;  minimum      INT,&#xa;  maximum      INT,&#xa;  config_value INT,&#xa;  run_value    INT );&#xa;  &#xa;-- Determine if the Advanced Options setting is enabled&#xa;INSERT INTO #Options&#xa;EXEC sp_configure 'Show Advanced Options';&#xa;&#xa;SELECT TOP 1 &#xa;  @AdvancedOptions = run_value&#xa;FROM&#xa;  #Options;&#xa;&#xa;-- If the Advanced Options are not enabled, enable them&#xa;IF @AdvancedOptions = 0&#xa;BEGIN&#xa;  EXEC sp_configure 'Show Advanced Options', 1;&#xa;  RECONFIGURE;&#xa;END&#xa;&#xa;-- Get the current Default Trace setting&#xa;-- Determine if the Advanced Options setting is enabled&#xa;TRUNCATE TABLE #Options;&#xa;INSERT INTO #Options&#xa;EXEC sp_configure 'Default Trace Enabled';&#xa;&#xa;SELECT TOP 1 &#xa;  @DefaultTrace = run_value&#xa;FROM&#xa;  #Options;&#xa;DROP TABLE #Options;&#xa;&#xa;-- Enable-Disable&#xa;IF @DefaultTrace = 1 and @Enable = 0&#xa;BEGIN&#xa;  EXEC sp_configure 'Default Trace Enabled', 0;&#xa;  RECONFIGURE;&#xa;  PRINT 'Default Trace Disabled';&#xa;END&#xa;ELSE IF @DefaultTrace = 0 and @Enable = 1&#xa;BEGIN&#xa;  EXEC sp_configure 'Default Trace Enabled', 1;&#xa;  RECONFIGURE;&#xa;  PRINT 'Default Trace Enabled';&#xa;END&#xa;ELSE IF @DefaultTrace = 0 and @Enable = 0&#xa;  PRINT 'The Default Trace is already disabled';&#xa;ELSE IF @DefaultTrace = 1 and @Enable = 1&#xa;  PRINT 'The Default Trace is already enabled';&#xa;  &#xa;-- Restore the Advanced Options to its original setting&#xa;IF @AdvancedOptions = 0&#xa;BEGIN&#xa;  EXEC sp_configure 'Show Advanced Options', 0;&#xa;  RECONFIGURE;&#xa;END&#xa;" name="Default Trace Enable - Disable - Enables or disables the Default Trace (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Returns events from the SQL Server Default Trace &#xa;-- (SQL Server 2005, 2008)&#xa;-- Events grouped by Database and in descending order&#xa;DECLARE @Path NVARCHAR(260);&#xa;&#xa;SELECT TOP 1&#xa;  @Path = path&#xa;FROM&#xa;  sys.traces&#xa;WHERE&#xa;  is_default = 1;&#xa;  &#xa;IF @Path IS NOT NULL&#xa;BEGIN&#xa;  SELECT &#xa;    t.DatabaseName,&#xa;    te.name &quot;EventName&quot;, &#xa;    t.EventClass,&#xa;    t.EventSubClass,&#xa;    t.StartTime,&#xa;    t.TextData,&#xa;    t.LoginName,&#xa;    t.NTUserName,&#xa;    t.HostName,&#xa;    t.ApplicationName,&#xa;    t.OwnerName,&#xa;    t.ObjectName&#xa;    --, t.*&#xa;  FROM &#xa;    fn_trace_gettable(@Path, Default) AS t&#xa;  LEFT JOIN&#xa;    sys.trace_events AS te&#xa;  ON &#xa;    t.EventClass = te.trace_event_id&#xa;  ORDER BY&#xa;    t.DatabaseName,&#xa;    t.EventSequence DESC;&#xa;END&#xa;" name="Default Trace Query - Returns events from the SQL Server Default Trace (SQL Server 2005, 2008)" type="1"/>
                        <node code="-- Displays events for the specified trace &#xa;-- (SQL Server 2000)&#xa;-- To see a list of running traces, execute:&#xa;-- SELECT * FROM ::fn_trace_getinfo(default)&#xa;SELECT &#xa;  *&#xa;FROM &#xa;  ::fn_trace_gettable($TraceFile$, Default);&#xa;" name="Trace Query (2000) - Displays events for the specified trace (SQL Server 2000)" type="1"/>
                        <node code="-- Displays events for the specified trace &#xa;-- (SQL Server 2005/2008)&#xa;-- To see a list of running traces, execute:&#xa;-- SELECT * from sys.traces&#xa;SELECT &#xa;  te.name &quot;EventName&quot;,&#xa;  t.*&#xa;FROM &#xa;  fn_trace_gettable($TraceFile$, Default) AS t&#xa;LEFT JOIN&#xa;  sys.trace_events AS te&#xa;ON &#xa;  t.EventClass = te.trace_event_id;&#xa;" name="Trace Query - Displays events for the specified trace (SQL Server 2005, 2008)" type="1"/>
                    </nodes>
                </node>
            </nodes>
        </node>
        <node name="Mathematical Functions" type="0">
            <nodes>
                <node code="ABS($numeric_expression$)" name="abs - Returns the absolute value for the expression." type="1"/>
                <node code="ACOS($float_expression$)" name="acos - Returns the angle (in radians) whose cosine is the specified argument." type="1"/>
                <node code="ASIN($float_expression$)" name="asin - Returns the angle (in radians) whose sine is the specified argument." type="1"/>
                <node code="ATAN($float_expression$)" name="atan - Returns the angle (in radians) whose tangent is the specified argument." type="1"/>
                <node code="ATAN2($float_expression1$, $float_expression2$)" name="atn2 - Returns the angle (in radians) whose tangent is argument1/argument1." type="1"/>
                <node code="CEILING($numeric_expression$)" name="ceiling - Returns the smallest integer that is greater than or equal to the argument." type="1"/>
                <node code="COS($float_expression$)" name="cos - Returns the cosine." type="1"/>
                <node code="COT($float_expression$)" name="cot - Returns the cotangent." type="1"/>
                <node code="DEGREES($numeric_expression$)" name="degrees - Converts radians to degrees." type="1"/>
                <node code="EXP($float_expression$)" name="exp - Returns the exponential value." type="1"/>
                <node code="FLOOR($numeric_expression$)" name="floor - Returns the largest integer that is less than or equal to the argument." type="1"/>
                <node code="LOG($float_expression$)" name="log - Returns a natural logarithm." type="1"/>
                <node code="LOG10($float_expression$)" name="log10 - Returns a base-10 logarithm." type="1"/>
                <node code="PI()" name="pi - Returns a Pi constant." type="1"/>
                <node code="POWER($numeric_expression$, $y$)" name="power - Converts argument1 to the power of argument2." type="1"/>
                <node code="RADIANS($numeric_expression$)" name="radians - Converts degrees to radians." type="1"/>
                <node code="RAND()&#xa;" name="rand - Returns a pseudo-random FLOAT type value between 0 and 1. If the seed is not specified, a random seed value is assigned." type="1"/>
                <node code="RAND($seed$)" name="rand2 - Returns a pseudo-random FLOAT type value between 0 and 1." type="1"/>
                <node code="ROUND($numeric_expression$, $length$)" name="round - Rounds an argument to the specified precision. When the parameter function is not specified, the numeric_expression is rounded instead of truncated." type="1"/>
                <node code="ROUND($numeric_expression$, $length$, $function$)" name="round2 - Rounds an argument to the specified precision." type="1"/>
                <node code="SIGN($numeric_expression$)" name="sign - Returns a -1 if the argument is negative, 0 if it is zero, and 1 if the argument is positive." type="1"/>
                <node code="SIN($float_expression$)" name="sin - Returns the sine." type="1"/>
                <node code="SQRT($float_expression$)" name="sqrt - Returns the square root of the expression." type="1"/>
                <node code="SQUARE($float_expression$)" name="square - Returns the square of the expression." type="1"/>
                <node code="TAN($float_expression$)" name="tan - Returns a tangent of the expression." type="1"/>
            </nodes>
        </node>
        <node name="Meta Data Functions" type="0">
            <nodes>
                <node code="COLUMNPROPERTY($id$, $column$, $property$)" name="columnproperty - Returns properties for the column." type="1"/>
                <node code="COL_LENGTH('$table$','$column$')" name="col_length - Returns the column length in bytes." type="1"/>
                <node code="COL_NAME($table_id$, $column_id$)" name="col_name - Returns the column name, given the table ID and column ID; where column ID is the ordinal position of the column." type="1"/>
                <node code="DATABASEPROPERTY('$_database$', '$property$')" name="databaseproperty - Returns properties for the database." type="1"/>
                <node code="DATABASEPROPERTYEX('$_database$', '$property$')" name="databasepropertyex - Returns the database settings and properties." type="1"/>
                <node code="DB_ID('$database_name$')" name="db_id - Returns the ID for the database specified in database_name." type="1"/>
                <node code="DB_NAME($database_id$)" name="db_name - Returns the name of the database based on the database_id." type="1"/>
                <node code="FILEGROUPPROPERTY('$_filegroup_name$', '$property$')" name="filegroupproperty - Returns properties for the filegroup based on the value specified in property." type="1"/>
                <node code="FILEGROUP_ID('$_filegroup_name$')" name="filegroup_id - Returns the file group ID for the logical filegroup name." type="1"/>
                <node code="FILEGROUP_NAME($_filegroup_id$)" name="filegroup_name - Returns the logical file group name for the filegroup ID." type="1"/>
                <node code="FILEPROPERTY($_file_name$, $property$)" name="fileproperty - Returns properties for the file based on the value specified in property." type="1"/>
                <node code="FILE_ID('$_file_name$')" name="file_id - Returns the file ID for the logical file name." type="1"/>
                <node code="FILE_IDEX ( $file_name$ )" name="file_idex - This function returns the file identification number for a particular file." type="1"/>
                <node code="FILE_NAME($_file_id$)" name="file_name - Returns the logical file name for the file ID." type="1"/>
                <node code="fn_listextendedproperty (&#xa;    $name$&#xa;    , $level0type$&#xa;    , $level0name$ &#xa;    , $level1type$&#xa;    , $level1name$&#xa;    , $level2type$&#xa;    , $level2name$&#xa;    )" name="fn_listextendedproperty - Returns extended properties for the specified objects." type="1"/>
                <node code="FULLTEXTCATALOGPROPERTY('$catalog_name$', '$property$')" name="fulltextcatalogproperty - Returns fulltext catalog properties." type="1"/>
                <node code="FULLTEXTSERVICEPROPERTY('$property$')" name="fulltextserviceproperty - Returns fulltext service level properties." type="1"/>
                <node code="INDEXKEY_PROPERTY($table_id$, $index_id$, $key_id$, '$property$') " name="indexkey_property - Returns the index key property." type="1"/>
                <node code="INDEXPROPERTY($table_id$, '$index$', '$property$')" name="indexproperty - Returns the index property." type="1"/>
                <node code="INDEX_COL('$table$', $index_id$, $key_id$)" name="index_col - Returns the index column name, given the table ID, index ID, and column sequential number in the index key." type="1"/>
                <node code="OBJECTPROPERTY($id$, '$property$')" name="objectproperty - Returns properties of objects in the current database." type="1"/>
                <node code="OBJECTPROPERTYEX( $id$ , $property$ )" name="objectpropertyex - This function returns information about a schema-scoped object." type="1"/>
                <node code="OBJECT_ID('$object$')" name="object_id - Returns the object ID for the specified object name." type="1"/>
                <node code="OBJECT_NAME($_object_id$)" name="object_name - Returns the object name for the specified object ID." type="1"/>
                <node code="@@PROCID" name="procid - Returns the stored procedure ID for the currently executing procedure." type="1"/>
                <node code="SQL_VARIANT_PROPERTY($expression$, '$property$')" name="sql_variant_property - Returns properties, including the base data type for the SQL_VARAINT." type="1"/>
                <node code="TYPEPROPERTY('$type$', '$property$')" name="typeproperty - Returns information about the data type properties." type="1"/>
                <node code="TYPE_ID($type_name$) " name="type_id - This function returns the ID of a data type." type="1"/>
                <node code="TYPE_ID($schema_name$ $type_name$) " name="type_id2 - This function returns the ID of a data type." type="1"/>
                <node code="TYPE_NAME($type_id$) " name="type_name - This function returns the type name of the specified type_id." type="1"/>
            </nodes>
        </node>
        <node name="Ranking Functions" type="0">
            <nodes>
                <node code="DENSE_RANK( )    &#xa;&#x9;OVER( $order_by_clause$ )" name="dense_rank - This function returns the rank of rows within a partition." type="1"/>
                <node code="DENSE_RANK( )    &#xa;&#x9;OVER( $partition_by_clause$ $order_by_clause$ )" name="dense_rank2 - This function returns the rank of rows within a partition." type="1"/>
                <node code="NTILE( $integer_expression$ )    &#xa;&#x9;OVER( $order_by_clause$ )&#x9;&#x9;" name="ntile - This function returns the group number of each row." type="1"/>
                <node code="NTILE( $integer_expression$ )    &#xa;&#x9;OVER( $partition_by_clause$ $order_by_clause$ )" name="ntile2 - This function returns the group number of each row." type="1"/>
                <node code="RANK( )    &#xa;&#x9;OVER( $order_by_clause$ )" name="rank - This function returns the rank of each row within a partition." type="1"/>
                <node code="RANK( )    &#xa;&#x9;OVER( $partition_by_clause$ $order_by_clause$ )" name="rank2 - This function returns the rank of each row within a partition." type="1"/>
                <node code="ROW_NUMBER( )     &#xa;&#x9;OVER( $order_by_clause$ )" name="row_number - This function returns the sequential row number of a row within a partition." type="1"/>
                <node code="ROW_NUMBER( )     &#xa;&#x9;OVER( $partition_by_clause$ $order_by_clause$ )&#xa;" name="row_number2 - This function returns the sequential row number of a row within a partition." type="1"/>
            </nodes>
        </node>
        <node name="Rowset Functions" type="0">
            <nodes>
                <node code="CONTAINSTABLE ( $table$, $column$, &#xa;    '$contains_search_condition$' )" name="containstable - This function returns a table that matches the specified search condition." type="1"/>
                <node code="CONTAINSTABLE ( $table$, $column$, &#xa;    '$contains_search_condition$', &#xa;    $LANGUAGE language_term$, &#xa;  &#x9;$top_n_by_rank$ )" name="containstable2 - This function returns a table that matches the specified search condition." type="1"/>
                <node code="FREETEXTTABLE ($table$, $column$, &#xa;     '$freetext_string$' )" name="freetexttable - This function returns a table that matches the meaning of the freetext_string." type="1"/>
                <node code="FREETEXTTABLE ($table$, $column$, &#xa;     '$freetext_string$', &#xa;     $LANGUAGE language_term$,&#xa;     $top_n_by_rank$ )" name="freetexttable2 - This function returns a table that matches the meaning of the freetext_string." type="1"/>
                <node code="OPENDATASOURCE( $provider_name$, $init_string$ )" name="opendatasource - This function creates an ad hoc connection and returns information associated with the connection." type="1"/>
                <node code="OPENQUERY( $linked_server$, '$query$' )" name="openquery - This function executes the query string on the linked_server." type="1"/>
                <node code="OPENROWSET ( { &#xa;&#x9;&#x9;'$provider_name$' ,&#xa;&#x9;&#x9;{ '$datasource$' ; '$user_id$' ; '$password$' | '$provider_string$' } , &#xa;&#x9;&#x9;{ $param1$  | '$query$' }  | BULK '$data_file$' , &#xa;&#x9;&#x9;{ FORMATFILE = '$format_file_path$' | $SINGLE_BLOB$ | $SINGLE_CLOB$ | $SINGLE_NCLOB$ }&#xa;} ) &#xa;" name="openrowset - This function creates an ad hoc connection and accesses data using OLE DB." type="1"/>
                <node code="OPENROWSET ( { &#xa;&#x9;&#x9;'$provider_name$' ,&#xa;&#x9;&#x9;{ '$datasource$' ; '$user_id$' ; '$password$' | '$provider_string$' } , &#xa;&#x9;&#x9;{ $catalog$.$schema$.$object$  | '$query$' }  | BULK '$data_file$' , &#xa;&#x9;&#x9;{ FORMATFILE = '$format_file_path$' $bulk_options$ | $SINGLE_BLOB$ | $SINGLE_CLOB$ | $SINGLE_NCLOB$ }&#xa;} ) &#xa;" name="openrowset2 - This function creates an ad hoc connection and accesses data using OLE DB." type="1"/>
                <node code="OPENXML( $idoc$ int, $rowpattern$ nvarchar )" name="openxml - This function returns a rowset view from an XML document." type="1"/>
                <node code="OPENXML( $idoc$ int in, $rowpattern$ nvarchar in, $flags$ byte in ) &#xa;&#x9;&#x9;WITH ( $SchemaDeclaration$ | $TableName$ )" name="openxml2 - This function returns a rowset view from an XML document." type="1"/>
            </nodes>
        </node>
        <node name="Security Functions" type="0">
            <nodes>
                <node code="fn_trace_geteventinfo($trace_id$)" name="fn_trace_geteventinfo - Returns the events defined for a particular trace." type="1"/>
                <node code="fn_trace_getfilterinfo($trace_id$)" name="fn_trace_getfilterinfo - Returns information about the filters defined on a particular trace." type="1"/>
                <node code="fn_trace_getinfo($trace_id$)" name="fn_trace_getinfo - Returns information about a specific trace or all traces defined on the current SQL Server instance." type="1"/>
                <node code="fn_trace_gettable($filename$, $number_files$)" name="fn_trace_gettable - Reads the contents of the trace." type="1"/>
                <node code="HAS_DBACCESS($database_name$)" name="has_dbaccess - Indicates whether the user can access the database." type="1"/>
                <node code="Has_perms_by_name ( $securable$ , &#xa;                    $securable_class$ , &#xa;                    $permission$ )" name="has_perms_by_name - This function evaluates a user's permission for a particular securable." type="1"/>
                <node code="Has_perms_by_name ( $securable$ , &#xa;                    $securable_class$ , &#xa;                    $permission$ , &#xa;                    $sub_securable$ , &#xa;                    $sub_securable_class$ )" name="has_perms_by_name2 - This function evaluates a user's permission for a particular securable." type="1"/>
                <node code="IS_MEMBER('$group | role$')" name="is_member - Returns true or false (1 or 0) depending on whether the current user is a member of the NT group or SQL Server role." type="1"/>
                <node code="IS_SRVROLEMEMBER('$role$')" name="is_srvrolemember - Returns true or false (1 or 0) depending on whether the user is a member of specified server role. If the user is not specified, the current user's membership is examined." type="1"/>
                <node code="IS_SRVROLEMEMBER('$role$', $login$)" name="is_srvrolemember2 - Returns true or false (1 or 0) depending on whether the user is a member of specified server role. If the user is not specified, the current user's membership is examined." type="1"/>
                <node code="SCHEMA_ID() &#xa;" name="schema_id - This function returns the schema ID of the caller's default schema." type="1"/>
                <node code="SCHEMA_ID( $schema_name$ )" name="schema_id2 - This function returns the schema ID of the specified schema name." type="1"/>
                <node code="SCHEMA_NAME()" name="schema_name - This function returns the schema name of the caller's default schema." type="1"/>
                <node code="SCHEMA_NAME( $schema_id$ )&#xa;" name="schema_name2 - This function returns the schema name of the specified schema ID." type="1"/>
                <node code="SETUSER" name="setuser - This function allows a user to impersonate another user. If the username parameter is not specified, the system admin or dB owner impersonating the user is reset." type="1"/>
                <node code="SETUSER '$username$'" name="setuser2 - This function allows a user to impersonate another user." type="1"/>
                <node code="SETUSER '$username$' WITH NORESET&#xa;" name="setuser3 - This function allows a user to impersonate another user. WITH NORESET indicates that succeeding SETUSER statments won't reset the user to system admin or dB owner if username is not specified." type="1"/>
                <node code="SUSER_SID()" name="suser_sid - Returns the Security ID (SID) for the current user or specified login in binary format." type="1"/>
                <node code="SUSER_SID($login$)" name="suser_sid2 - Returns the Security ID (SID) for the current user or specified login in binary format." type="1"/>
                <node code="SUSER_SNAME()" name="suser_sname - Returns the login name for the current user or specified login's Security ID (SID)." type="1"/>
                <node code="SUSER_SNAME($server_user_sid$)" name="suser_sname2 - Returns the login name for the current user or specified login's Security ID (SID)." type="1"/>
                <node code="sys.fn_builtin_permissions( $DEFAULT$ | N'$securable_class$' )" name="sys.fn_builtin_permissions - This function returns information regarding the server's built-in permissions hierarchy." type="1"/>
                <node code="USER" name="user - Returns the user name in the current database for the current connection." type="1"/>
                <node code="USER_ID()" name="user_id - Returns the user ID in the current database." type="1"/>
                <node code="USER_ID($user$)" name="user_id2 - Returns the user ID in the current database." type="1"/>
            </nodes>
        </node>
        <node name="SQL Statements" type="0">
            <nodes>
                <node code="SELECT * FROM $table_source$" name="sel - Retrieves data from a table." type="1"/>
                <node code="SELECT * FROM $table_source$ WHERE $search_criteria$" name="selwhere - Limits the resultset by providing search criteria. If no where clause is specified, all records are retrieved." type="1"/>
            </nodes>
        </node>
        <node name="Stored Procedures" type="0">
            <nodes>
                <node code="IF EXISTS (SELECT * &#xa;&#x9;FROM   sysobjects &#xa;&#x9;WHERE  name = N'$inline_func_name$')&#xa;&#x9;DROP FUNCTION $inline_func_name$&#xa;%batch_separator%&#xa;&#xa;CREATE FUNCTION $inline_func_name$(@$param_name$ $param_type$)&#xa;RETURNS TABLE&#xa;AS&#xa;BEGIN&#xa;&#x9;RETURN (SELECT $selected$$end$) &#xa;END&#xa;%batch_separator%" name="inlinefunc - Creates an inline table valued function. This is a useful alternative to a dynamic view since it can accept parameters." type="1"/>
                <node code="IF EXISTS (SELECT * &#xa;&#x9;FROM   sysobjects &#xa;&#x9;WHERE  name = N'$inline_func_name$')&#xa;&#x9;DROP FUNCTION $inline_func_name$&#xa;%batch_separator%&#xa;&#xa;CREATE FUNCTION $inline_func_name$(@$param_name$ $param_type$)&#xa;RETURNS TABLE&#xa;AS&#xa;BEGIN&#xa;&#x9;RETURN (SELECT $selected$$end$) &#xa;END&#xa;%batch_separator%" name="inlinefunc_surroundwith - Creates an inline table valued function. This is a useful alternative to a dynamic view since it can accept parameters." type="1"/>
                <node code="IF EXISTS (SELECT name FROM sysobjects &#xa;&#x9;WHERE name = N'$proc_name$' AND type = 'P')&#xa;&#x9;DROP PROCEDURE $proc_name$&#xa;%batch_separator%&#xa;&#xa;CREATE PROCEDURE $proc_name$ @$param_name$ $param_type$&#xa;AS&#xa;&#x9;$selected$$end$&#xa;%batch_separator%" name="proc - null" type="1"/>
                <node code="IF EXISTS (SELECT name FROM sysobjects &#xa;&#x9;WHERE name = N'$proc_name$' AND type = 'P')&#xa;&#x9;DROP PROCEDURE $proc_name$&#xa;%batch_separator%&#xa;&#xa;CREATE PROCEDURE $proc_name$ @$param_name$ $param_type$&#xa;AS&#xa;&#x9;$selected$$end$&#xa;%batch_separator%" name="proc_surroundwith - null" type="1"/>
                <node code="IF EXISTS (SELECT * &#xa;&#x9;FROM   sysobjects &#xa;&#x9;WHERE  name = N'$scalar_func_name$')&#xa;&#x9;DROP FUNCTION $scalar_func_name$&#xa;%batch_separator%&#xa;&#xa;CREATE FUNCTION $scalar_func_name$(@$param_name$ $param_type$)&#xa;RETURNS $return_type$&#xa;AS&#xa;BEGIN&#xa;&#x9;$selected$$end$&#xa;&#x9;RETURN $scalar_expression$&#xa;END&#xa;%batch_separator%" name="scalarfunc - Creates a scalar function. This is useful when you need to perform the same operation on strings or numeric data repeatedly." type="1"/>
                <node code="IF EXISTS (SELECT * &#xa;&#x9;FROM   sysobjects &#xa;&#x9;WHERE  name = N'$scalar_func_name$')&#xa;&#x9;DROP FUNCTION $scalar_func_name$&#xa;%batch_separator%&#xa;&#xa;CREATE FUNCTION $scalar_func_name$(@$param_name$ $param_type$)&#xa;RETURNS $return_type$&#xa;AS&#xa;BEGIN&#xa;&#x9;$selected$$end$&#xa;&#x9;RETURN $scalar_expression$&#xa;END&#xa;%batch_separator%" name="scalarfunc_surroundwith - Creates a scalar function. This is useful when you need to perform the same operation on strings or numeric data repeatedly." type="1"/>
                <node code="IF EXISTS (SELECT * &#xa;&#x9;FROM   sysobjects &#xa;&#x9;WHERE  name = N'$table_func_name$')&#xa;&#x9;DROP FUNCTION $table_func_name$&#xa;%batch_separator%&#xa;&#xa;CREATE FUNCTION $table_func_name$(@$param_name$ $param_type$)&#xa;RETURNS @$return_variable$ TABLE ($column_1$ $column_1_type$, $column_2$ $column_2_type$) &#xa;BEGIN&#xa;  $selected$$end$&#xa;  RETURN&#xa;END&#xa;%batch_separator%" name="tablefunc - Creates a multi-statement table-valued function. This is useful because you can use control-of-flow statements, assignments, cursors, and other statements within the function." type="1"/>
                <node code="IF EXISTS (SELECT * &#xa;&#x9;FROM   sysobjects &#xa;&#x9;WHERE  name = N'$table_func_name$')&#xa;&#x9;DROP FUNCTION $table_func_name$&#xa;%batch_separator%&#xa;&#xa;CREATE FUNCTION $table_func_name$(@$param_name$ $param_type$)&#xa;RETURNS @$return_variable$ TABLE ($column_1$ $column_1_type$, $column_2$ $column_2_type$) &#xa;BEGIN&#xa;  $selected$$end$&#xa;  RETURN&#xa;END&#xa;%batch_separator%" name="tablefunc_surroundwith - Creates a multi-statement table-valued function. This is useful because you can use control-of-flow statements, assignments, cursors, and other statements within the function." type="1"/>
            </nodes>
        </node>
        <node name="String Functions" type="0">
            <nodes>
                <node code="ASCII($character_expression$)" name="ascii - Converts a character to a numeric ASCII code." type="1"/>
                <node code="CHAR($integer_expression$)" name="char - Converts a numeric ASCII code to a character." type="1"/>
                <node code="CHARINDEX($expression1$, $expression2$)" name="charindex - Returns the position of the first occurrence of a substring within a string." type="1"/>
                <node code="CHARINDEX($expression1$, $expression2$, $start_location$)" name="charindex2 - Returns the position of the first occurrence of a substring within a string." type="1"/>
                <node code="DIFFERENCE($character_expression1$, $character_expression2$)" name="difference - Compares how two arguments sound and returns a number from 0 to 4. A higher result indicates a better phonetic match." type="1"/>
                <node code="LEFT($character_expression$, $integer_expression$)" name="left - Returns a portion of a character expression, starting at integer_expression from the left." type="1"/>
                <node code="LEN($string_expression$)" name="len - Returns the number of characters in the expression." type="1"/>
                <node code="LOWER($character_expression$)" name="lower - Converts a string to lowercase." type="1"/>
                <node code="LTRIM($character_expression$)" name="ltrim - Trims the leading space characters." type="1"/>
                <node code="NCHAR($integer_expression$)" name="nchar - Returns the Unicode character with the given integer code." type="1"/>
                <node code="PATINDEX('%$pattern$%', $expression$)" name="patindex - Returns the position of the first occurrence of a pattern in a string." type="1"/>
                <node code="QUOTENAME('$character_string$')" name="quotename - Adds delimiters to the Unicode string." type="1"/>
                <node code="QUOTENAME('$character_string$', '$quote_character$')" name="quotename2 - Adds delimiters to the Unicode string." type="1"/>
                <node code="REPLACE('$string_expression1$', '$string_expression2$', '$string_expression3$')" name="replace - Replaces the occurrence of the second expression with the third expression IN the first expression." type="1"/>
                <node code="REPLICATE($character_expression$, $integer_expression$)" name="replicate - Repeats a string the number of times specified in integer_expression." type="1"/>
                <node code="REVERSE($character_expression$)" name="reverse - Reverses characters in a string." type="1"/>
                <node code="RIGHT($character_expression$, $integer_expression$)" name="right - Returns a portion of a character expression, starting at integer_expression from the right." type="1"/>
                <node code="RTRIM($character_expression$)" name="rtrim - Trims trailing space characters." type="1"/>
                <node code="SOUNDEX($character_expression$)" name="soundex - Returns a 4-character code based on how the argument string sounds." type="1"/>
                <node code="SPACE($integer_expression$)" name="space - Returns a string consisting of a given number of space characters." type="1"/>
                <node code="STR($float_expression$)" name="str - Converts numeric data to character strings." type="1"/>
                <node code="STR($float_expression$, $length$)&#xa;" name="str2 - Converts numeric data to character strings." type="1"/>
                <node code="STR($float_expression$, $length$, $decimal$)" name="str3 - Converts numeric data to character strings." type="1"/>
                <node code="STUFF($character_expression1$, $start$, $_length$, $character_expression2$)" name="stuff - Replaces a part of one string with another string." type="1"/>
                <node code="SUBSTRING($expression$, $start$, $_length$)" name="substring - Extracts a part of a string." type="1"/>
                <node code="UNICODE('$ncharacter_expression$')" name="unicode - Returns the Unicode integer value for the first character of the input parameter." type="1"/>
                <node code="UPPER($character_expression$)" name="upper - Converts a string to uppercase." type="1"/>
            </nodes>
        </node>
        <node name="System Functions" type="0">
            <nodes>
                <node code="APP_NAME()" name="app_name - Returns the name of the application." type="1"/>
                <node code="CAST($expression$ AS $data_type$)" name="cast - Converts a valid SQL Server expression to the specified data type." type="1"/>
                <node code="COALESCE($expression$)" name="coalesce - Returns the first non-NULL argument from a list of arguments." type="1"/>
                <node code="COALESCE($expression$ $[,...n ]$)" name="coalesce2 - Returns the first non-NULL argument from a list of arguments." type="1"/>
                <node code="COLLATIONPROPERTY($collation_name$, $property$)" name="collationproperty - Returns properties for the collation." type="1"/>
                <node code="COLUMNS_UPDATED()" name="columns_updated - This function returns a bit pattern of type varbinary to indicate which columns have been modified." type="1"/>
                <node code="CONVERT($data_type$, $expression$)" name="convert - Converts data from one datatype to another." type="1"/>
                <node code="CONVERT($data_type$($length$), $expression$, $style$)" name="convert2 - Converts data from one datatype to another." type="1"/>
                <node code="CURRENT_TIMESTAMP" name="current_timestamp - Returns the current date and time." type="1"/>
                <node code="CURRENT_USER" name="current_user - Returns the user name in the current database of the current session:" type="1"/>
                <node code="DATALENGTH($expression$)" name="datalength - Returns the number of bytes in a character or binary string." type="1"/>
                <node code="@@ERROR" name="error - Returns the error number for the last T-SQL statement executed. If this value is zero, there were no errors." type="1"/>
                <node code="ERROR_LINE()&#xa;" name="error_line - This function returns the line number that caused the error to occur." type="1"/>
                <node code="ERROR_MESSAGE()" name="error_message - This function returns the error message that caused the error." type="1"/>
                <node code="ERROR_NUMBER()" name="error_number - This function returns the error number that caused the error." type="1"/>
                <node code="ERROR_PROCEDURE()" name="error_procedure - This function returns the stored procedure name or trigger name of where the error occurred." type="1"/>
                <node code="ERROR_SEVERITY()" name="error_severity - This function returns the severity of the error." type="1"/>
                <node code="ERROR_STATE()" name="error_state - This function returns the state number of the error." type="1"/>
                <node code="fn_helpcollations()" name="fn_helpcollations - Returns supported collations for SQL Server." type="1"/>
                <node code="fn_servershareddrives()" name="fn_servershareddrives - Returns the name of any shared drives used by the clustered server." type="1"/>
                <node code="FORMATMESSAGE($msg_number$, $param_value$)" name="formatmessage - Constructs a message from an existing message in the SYSMESSAGES table." type="1"/>
                <node code="FORMATMESSAGE($msg_number$, $param_value$ $[,...n]$)" name="formatmessage2 - Constructs a message from an existing message in the SYSMESSAGES table." type="1"/>
                <node code="GETANSINULL()" name="getansinull - Returns the default nullability setting for new columns." type="1"/>
                <node code="GETANSINULL('$database$')" name="getansinull2 - Returns the default nullability setting for new columns." type="1"/>
                <node code="HOST_ID()" name="host_id - Returns the workstation ID of a given process." type="1"/>
                <node code="HOST_NAME()" name="host_name - Returns the process host name." type="1"/>
                <node code="IDENTITY($data_type$) AS $column_name$" name="identity - Used in a SELECT INTO statement to insert an identity column into the destination table." type="1"/>
                <node code="IDENTITY($data_type$, $seed$, $increment$) AS $column_name$" name="identity2 - Used in a SELECT INTO statement to insert an identity column into the destination table." type="1"/>
                <node code="@@IDENTITY" name="identity_global - Returns the last IDENTITY value inserted. If there are not any IDENTITY values inserted, this variable is NULL." type="1"/>
                <node code="IDENT_CURRENT('$table_name$')" name="ident_current - Returns the last identity value generated for the specified table." type="1"/>
                <node code="IDENT_INCR('$table_or_view$')" name="ident_incr - Returns the identity column increment value." type="1"/>
                <node code="IDENT_SEED('$table_or_view$')" name="ident_seed - Returns the identity seed value." type="1"/>
                <node code="ISDATE($expression$)" name="isdate - Validates wether a character string can be converted to DATETIME." type="1"/>
                <node code="ISNULL($check_expression$, $replacement_value$)" name="isnull - Returns the first argument if it is not NULL, otherwise it returns the second argument." type="1"/>
                <node code="ISNUMERIC($expression$)" name="isnumeric - Validates whether a character string can be converted to NUMERIC." type="1"/>
                <node code="NEWID()" name="newid - Creates a new unique identifier of the data type." type="1"/>
                <node code="NULLIF($expression1$, $expression2$)" name="nullif - Returns a NULL if two expressions specified are equivalent." type="1"/>
                <node code="PARSENAME('$_object_name$', $object_piece$)" name="parsename - Returns the database name, owner name, server name, or object name for the object specified. Object piece is an integer between 1 and 4." type="1"/>
                <node code="PERMISSIONS()" name="permissions - Returns a value containing a bitmap with current users permissions on the specified object / column." type="1"/>
                <node code="PERMISSIONS($objectid$)" name="permissions2 - Returns a value containing a bitmap with current users permissions on the specified object / column." type="1"/>
                <node code="PERMISSIONS($objectid$, '$column$')" name="permissions3 - Returns a value containing a bitmap with current users permissions on the specified object / column." type="1"/>
                <node code="@@ROWCOUNT" name="rowcount - Returns the number of rows affected by the last query." type="1"/>
                <node code="ROWCOUNT_BIG()" name="rowcount_big - Returns the number of rows affected by the last query." type="1"/>
                <node code="SCOPE_IDENTITY()" name="scope_identity - Returns the last identity added to an identity column that matches the specified scope." type="1"/>
                <node code="SERVERPROPERTY('$propertyname$')" name="serverproperty - Returns properties for the server." type="1"/>
                <node code="SESSIONPROPERTY('$option$')" name="sessionproperty - Returns properties for the current session." type="1"/>
                <node code="SESSION_USER" name="session_user - Returns user name in the current connection." type="1"/>
                <node code="STATS_DATE($table_id$, $index_id$)" name="stats_date - Returns the date and time when index statistics were last updated." type="1"/>
                <node code="sys.dm_db_index_physical_stats ( &#xa;    $param1$&#xa;    , $param2$&#xa;    , $param3$&#xa;    , $param4$&#xa;    , $param5$&#xa;)&#xa;" name="sys.dm_db_index_physical_stats  - This function returns information about size and fragmentation for data and indexes of the associated table or view." type="1"/>
                <node code="SYSTEM_USER" name="system_user - Returns the login name for the current session." type="1"/>
                <node code="@@TRANCOUNT" name="trancount - Returns the number of open transactions for the current connection." type="1"/>
                <node code="UPDATE( $column$ ) " name="update - This function determines whether an insert or update was performed on a column of a table and returns a boolean value." type="1"/>
                <node code="USER_NAME()" name="user_name - Returns the user name in the current database." type="1"/>
                <node code="USER_NAME($id$)" name="user_name2 - Returns the user name in the current database." type="1"/>
                <node code="XACT_STATE()" name="xact_state - This function determines if a request consists of an active user transaction and if the transaction can be committed." type="1"/>
            </nodes>
        </node>
        <node name="System Statistical Functions" type="0">
            <nodes>
                <node code="@@CONNECTIONS" name="connections - Returns the number of successful and failed connections since SQL Server was last started." type="1"/>
                <node code="@@CPU_BUSY" name="cpu_busy - Returns the number of milliseconds the CPU has spent working since SQL Server was last started." type="1"/>
                <node code="fn_virtualfilestats($database_id$, $_file_id$)" name="fn_virtualfilestats - Returns I/O statistics, including the log files, associated with the database." type="1"/>
                <node code="@@IDLE" name="idle - Returns the number of milliseconds SQL Server has been idle since it was last started." type="1"/>
                <node code="@@IO_BUSY" name="io_busy - Returns the number of milliseconds SQL Server has spent performing I/O operations since it was last started." type="1"/>
                <node code="@@PACKET_ERRORS" name="packet_errors - Returns the number of network packet errors since SQL Server was last started." type="1"/>
                <node code="@@PACK_RECEIVED" name="pack_received - Returns the number of network packets received by SQL Server since it was last started." type="1"/>
                <node code="@@PACK_SENT" name="pack_sent - Returns the number of network packets sent by SQL Server since it was last started." type="1"/>
                <node code="@@TIMETICKS" name="timeticks - Returns the number of microseconds per tick, which is computer processor-dependent." type="1"/>
                <node code="@@TOTAL_ERRORS" name="total_errors - Returns the number of disk read and write errors encountered since SQL Server was last started." type="1"/>
                <node code="@@TOTAL_READ" name="total_read - Returns the total number of disk reads since SQL Server was last started. This does not include reading from the memory." type="1"/>
                <node code="@@TOTAL_WRITE" name="total_write - Returns the number of open transactions for the current connection." type="1"/>
            </nodes>
        </node>
        <node name="Templates" type="0">
            <nodes>
                <node code="sp_addsrvrolemember @loginame = '$login_name$', &#xa;&#x9;@rolename = '$server_role$'" name="addlogin - Adds a login to a fixed server role." type="1"/>
                <node code="sp_addrolemember  @rolename   = '$db_role$', &#xa;&#x9;@membername = '$_user_name$'" name="adduser - Assigns users to an existing role in the database." type="1"/>
                <node code="IF EXISTS(SELECT * FROM sys.objects WHERE name = N'$aggregate_name$' &#xa;&#x9;AND (type = 'AF'))  &#xa;DROP AGGREGATE $aggregate_name$&#xa;%batch_separator%&#xa;&#xa;CREATE AGGREGATE $aggregate_name$(@$parameter_name$ $parameter_type$)&#xa;&#x9;RETURNS $return_type$&#xa;&#x9;EXTERNAL NAME $assembly_name$.$clr_type_name$&#xa;%batch_separator%&#xa;" name="aggregate - null" type="1"/>
                <node code="IF EXISTS(SELECT * FROM sys.assemblies &#xa;&#x9;WHERE name = N'$assembly_name$')&#xa;DROP ASSEMBLY $assembly_name$&#xa;%batch_separator%&#xa;&#xa;CREATE ASSEMBLY $assembly_name$&#xa;FROM N'$assembly_dll_path$'&#xa;%batch_separator%&#xa;" name="assembly - null" type="1"/>
                <node code="CASE &#xa;&#x9;WHEN $boolean_expression1$ THEN $result_expression1$&#xa;&#x9;WHEN $boolean_expression2$ THEN $result_expression2$&#xa;&#x9;WHEN $boolean_expression3$ THEN $result_expression3$&#xa;&#x9;ELSE $else_result_expression$ &#xa;END" name="casesearch - Performs conditional checks and returns the value accordingly." type="1"/>
                <node code="CASE $input_expression$&#xa;&#x9;WHEN $when_expression1$ THEN $result_expression1$&#xa;&#x9;WHEN $when_expression2$ THEN $result_expression2$&#xa;&#x9;WHEN $when_expression3$ THEN $result_expression3$&#xa;&#x9;WHEN $when_expression4$ THEN $result_expression4$&#xa;&#x9;WHEN $when_expression5$ THEN $result_expression5$&#xa;&#x9;ELSE $else_result_expression$ &#xa;END" name="casesimple - Compares a specific value to a list of other values and returns a different result in each circumstance." type="1"/>
                <node code="IF EXISTS(SELECT * FROM sys.certificates WHERE name = N'$certificate_name$')&#xa;DROP CERTIFICATE $certificate_name$&#xa;%batch_separator%&#xa;&#xa;CREATE CERTIFICATE $certificate_name$ &#xa;&#x9;ENCRYPTION BY PASSWORD = $certificate_password$&#xa;&#x9;WITH SUBJECT = $certificate_subject$&#xa;%batch_separator%&#xa;" name="certificate - null" type="1"/>
                <node code="CREATE UNIQUE CLUSTERED INDEX $index_name$&#xa;ON $database_name$.$owner$.$table_or_view_name$ &#xa;&#x9;($column_1$, &#xa;&#x9; $column_2$)&#xa;WITH&#xa;PAD_INDEX,&#xa;FILLFACTOR = $fillfactor_value$,&#xa;IGNORE_DUP_KEY,&#xa;DROP_EXISTING,&#xa;STATISTICS_NORECOMPUTE&#xa;ON $_filegroup_name$" name="clusteredidx - Creates a clustered index, which contains actual data values on its leaf level. The sort order of the clustered index determines the sort order of the actual data in the table." type="1"/>
                <node code="DECLARE $cursor_name$ CURSOR FOR &#xa;$select_statement$ &#xa;&#xa;DECLARE $_variable_name$ $data type$&#xa;&#xa;OPEN $cursor_name$&#xa;FETCH NEXT FROM $cursor_name$ into $_variable_name$ &#xa;WHILE @@FETCH_STATUS = 0&#xa;BEGIN&#xa;&#x9;PRINT $_variable_name$&#xa;&#x9;FETCH NEXT FROM $cursor_name$ &#xa;END&#xa;&#xa;CLOSE $cursor_name$&#xa;DEALLOCATE $cursor_name$" name="cursor - Creates a cursor and defines a SELECT statement that may join multiple tables and views to create the recordset referenced by the cursor." type="1"/>
                <node code="CREATE DATABASE $database_name$&#xa;ON PRIMARY&#xa;&#x9;( NAME = $file_name_1$,&#xa;&#x9;  FILENAME = '$c:\program files\microsoft sql server\mssql\data\data_1.mdf$',&#xa;&#x9;  SIZE = 10MB,&#xa;&#x9;  MAXSIZE = 100MB,&#xa;&#x9;  FILEGROWTH = 10%),&#xa;&#x9;&#xa;&#x9;( NAME = $file_name_2$,&#xa;&#x9;  FILENAME = '$c:\program files\microsoft sql server\mssql\data\data_2.ndf$',&#xa;&#x9;  SIZE = 10MB,&#xa;&#x9;  MAXSIZE = 100MB,&#xa;&#x9;  FILEGROWTH = 10%),&#xa;&#xa;FILEGROUP $file_group_name_1$&#xa;&#x9;( NAME = $file_name_3$,&#xa;&#x9;  FILENAME = '$c:\program files\microsoft sql server\mssql\data\data_3.ndf$',&#xa;&#x9;  SIZE = 10MB,&#xa;&#x9;  MAXSIZE = 100MB,&#xa;&#x9;  FILEGROWTH = 10%),&#xa;&#x9;&#xa;&#x9;( NAME = $file_name_4$,&#xa;&#x9;  FILENAME = '$c:\program files\microsoft sql server\mssql\data\data_4.ndf$',&#xa;&#x9;  SIZE = 10MB,&#xa;&#x9;  MAXSIZE = 100MB,&#xa;&#x9;  FILEGROWTH = 10%)&#xa;&#xa;LOG ON&#xa;&#x9;( NAME = $log_file_name_1$,&#xa;&#x9;  FILENAME = '$c:\program files\microsoft sql server\mssql\data\log_1.ldf$',&#xa;&#x9;  SIZE = 10MB,&#xa;&#x9;  MAXSIZE = 100MB,&#xa;&#x9;  FILEGROWTH = 10%)&#xa;%batch_separator%" name="db - Creates a database." type="1"/>
                <node code="DELETE &#xa;FROM $table_name$ &#xa;WHERE $condition$" name="delrows - Deletes rows in the specified table." type="1"/>
                <node code="IF EXISTS(SELECT * FROM sys.objects WHERE name = N'$aggregate_name$' &#xa;&#x9;AND (type = 'AF'))  &#xa;DROP AGGREGATE $aggregate_name$&#xa;%batch_separator%&#xa;" name="dropaggregate - null" type="1"/>
                <node code="IF EXISTS(SELECT * FROM sys.assemblies &#xa;&#x9;WHERE name = N'$assembly_name$')&#xa;DROP ASSEMBLY $assembly_name$&#xa;%batch_separator%&#xa;" name="dropassembly - null" type="1"/>
                <node code="IF EXISTS(SELECT * FROM sys.certificates WHERE name = N'$certificate_name$')&#xa;DROP CERTIFICATE $certificate_name$&#xa;%batch_separator%&#xa;" name="dropcertificate - null" type="1"/>
                <node code="IF EXISTS (SELECT * FROM sys.fulltext_catalogs WHERE name = N'$fulltext_catalog_name$')&#xa;DROP FULLTEXT CATALOG $fulltext_catalog_name$&#xa;%batch_separator%&#xa;" name="dropfulltextcatalog - null" type="1"/>
                <node code="sp_droplogin @loginame = '$login_name$'" name="droplogin - Removes a SQL Server authenticated login from the sysxlogins table." type="1"/>
                <node code="sp_dropgroup @rolename = '$database_role$'" name="droprole - Removes a role from the database. This feature is provided for backward compatibility. All new code should use sp_droprole instead." type="1"/>
                <node code="IF EXISTS(SELECT * FROM sys.synonyms WHERE name = N'$synonym_name$')&#xa;DROP SYNONYM $synonym_name$&#xa;%batch_separator%&#xa;" name="dropsynonym - null" type="1"/>
                <node code="sp_dropuser @name_in_db = '$_user_name$'" name="dropuser - Revokes a user's access to the database. This feature is provided for backward compatibility. All new code should use sp_revokedbaccess instead." type="1"/>
                <node code="IF EXISTS (SELECT * FROM sys.xml_schema_collections WHERE name = N'$xml_schema_collection_name$')&#xa;DROP XML SCHEMA COLLECTION $xml_schema_collection_name$&#xa;%batch_separator%&#xa;" name="dropxmlschemacollection - null" type="1"/>
                <node code="IF EXISTS (SELECT * FROM sys.fulltext_catalogs WHERE name = N'$fulltext_catalog_name$')&#xa;DROP FULLTEXT CATALOG $fulltext_catalog_name$&#xa;%batch_separator%&#xa; &#xa;CREATE FULLTEXT CATALOG $fulltext_catalog_name$&#xa;%batch_separator%&#xa;" name="fulltextcatalog - null" type="1"/>
                <node code="IF $condition$&#xa;BEGIN&#xa;&#x9;$code$&#xa;END" name="if - Evaluates a Boolean condition and executes an appropriate set of commands." type="1"/>
                <node code="IF $condition$&#xa;BEGIN&#xa;&#x9;$if code$&#xa;END&#xa;ELSE&#xa;BEGIN&#xa;&#x9;$else code$&#xa;END" name="ifelse - Evaluates a Boolean condition and executes the condition if the condition is true. If the condition is false, executes the ELSE condition." type="1"/>
                <node code="SELECT $column_name$&#xa;FROM $table_name_1$ $alias1$ &#xa;&#x9;INNER JOIN $table_name_2$ $alias2$&#xa;&#x9;ON $alias1$.$key$ = $alias2$.$key$&#xa;WHERE $conditions$&#xa;ORDER BY $order_by_expression$" name="innerjoin - Returns all matching pairs of rows for the join." type="1"/>
                <node code="SELECT $column_name$&#xa;FROM $table_name_1$ $alias1$ &#xa;&#x9;LEFT OUTER JOIN $table_name_2$ $alias2$&#xa;&#x9;ON $alias1$.$key$ = $alias2$.$key$&#xa;WHERE $conditions$&#xa;ORDER BY $order_by_expression$" name="leftouterjoin - Returns all matching pairs of rows AND the rows that do not meet the join criteria from the table specified by the LEFT column order." type="1"/>
                <node code="sp_addlogin @loginame    = '$login_name$',&#xa;&#x9;&#x9;@passwd      = '$password$',&#xa;&#x9;&#x9;@defdb       = '$database$',&#xa;&#x9;&#x9;@deflanguage = '$_language$',&#xa;&#x9;&#x9;@sid         = $sid$,&#xa;&#x9;&#x9;@encryptopt  = $encryption_option$" name="login - Adds a login specified with the login_name parameter to the local server. Only members of the sysadmin fixed server role can execute this procedure." type="1"/>
                <node code="CREATE INDEX $index_name$&#xa;ON $database_name$.$owner$.$table_or_view_name$ &#xa;&#x9;($column_1$, &#xa;&#x9; $column_2$)" name="nonclusteredidx - Creates an index that defines the logical order of a table; while the physical order of the data in the table is independent of the index order." type="1"/>
                <node code="EXEC sp_addrole '$role_name$'" name="role - Adds a role to the current database." type="1"/>
                <node code="CREATE STATISTICS $statistics_name$ &#xa;ON $table_name$ &#xa;&#x9;($column_name$)&#xa;WITH&#xa;SAMPLE $percentage$ PERCENT" name="stat - Creates distribution statistics for one or more columns in a table or indexed view. This is useful for determining how your data is distributed on pages, how many duplicates there are in the column, etc., and for optimizing SQL Server performance." type="1"/>
                <node code="IF EXISTS(SELECT * FROM sys.synonyms WHERE name = N'$synonym_name$')&#xa;DROP SYNONYM $synonym_name$&#xa;%batch_separator%&#xa;&#xa;CREATE SYNONYM $synonym_schema_name$.$synonym_name$ FOR&#xa;$database_name$.$schema_name$.$obj_name$&#xa;%batch_separator%&#xa;" name="synonym - null" type="1"/>
                <node code="CREATE TABLE $table_name$ (&#xa;$column_1$ $datatype_for_column_1$ NOT NULL, &#xa;$column_2$ $datatype_for_column_2$ NULL,&#xa;PRIMARY KEY ( $column_1$ ))" name="table - Creates a table for the specified database. Along with specifying column names, their data types and nullability, you can define primary and foreign keys for this table, create default and check constraints,  and create indexes." type="1"/>
                <node code="CREATE TRIGGER $trigger_name$&#xa;ON $table_name$&#xa;FOR DELETE, INSERT, UPDATE &#xa;AS &#xa;BEGIN&#xa;&#x9;$perform an operation$&#xa;END" name="trigger - Creates a trigger for a specified table. The trigger fires when executing a particular data modification language statement for which the trigger was defined." type="1"/>
                <node code="UPDATE $table_name$&#xa;SET    $column_name1$ = '$value1$'&#xa;WHERE  $column_name2$ = '$value2$'" name="updatetable - Modifies data in database objects." type="1"/>
                <node code="sp_adduser @loginame   = '$login_name$', &#xa;&#x9;@name_in_db = '$_user_name$',&#xa;&#x9;@grpname    = '$db_role_name$'" name="user - Grants a user's access to the database. This feature is provided for backward compatibility. All new code should use sp_grantdbaccess instead." type="1"/>
                <node code="CREATE VIEW $view_name$&#xa;AS &#xa;$select_statement$" name="view - Creates a view on tables or existing views. Views provide an easy way to secure access to sensitive data." type="1"/>
                <node code="IF EXISTS (SELECT * FROM sys.xml_schema_collections WHERE name = N'$xml_schema_collection_name$')&#xa;DROP XML SCHEMA COLLECTION $xml_schema_collection_name$&#xa;%batch_separator%&#xa;&#xa;CREATE XML SCHEMA COLLECTION $xml_schema_collection_name$&#xa;AS &#xa;N'$xml_schema_expression$'&#xa;%batch_separator%&#xa;" name="xmlschemacollection - null" type="1"/>
            </nodes>
        </node>
        <node name="Text and Image Functions" type="0">
            <nodes>
                <node code="PATINDEX('%$pattern$%', $expression$)" name="patindex - Returns the position of the first occurrence of a pattern in a string." type="1"/>
                <node code="TEXTPTR($column$)" name="textptr - Returns a pointer to a text, ntext, or image column in varbinary format." type="1"/>
                <node code="TEXTVALID('$table.column$', $text_ptr$)" name="textvalid - Returns true or false (1 or 0) depending on whether the pointer to the text, ntext or image column is valid." type="1"/>
            </nodes>
        </node>
        <node name="Miscellaneous" type="0">
            <nodes>
                <node code="select top 10 * from employee" name="Get top N rows (example)" type="1"/>
                <node code="CREATE TABLE ##test_temp_table (field_name varchar(100), pk NUMERIC(32), old_pk NUMERIC(32));" name="Create temporary table (example)" type="1"/>
                <node code="SELECT GETDATE()" name="Get current date+time" type="1"/>
                <node code="SELECT 'something'" name="dummy/dual table" type="1"/>
            </nodes>
        </node>
        <node name="Autoincrement field" type="0">
            <nodes>
                <node code="create table config_property_test&#xa;(&#xa;   CONFIG_PROPERTY_NUM INT PRIMARY KEY IDENTITY,&#xa;   NAME&#x9;VARCHAR(255)&#xa;)      " name="Create table with autoincrement field (example)" type="1"/>
                <node code="insert into config_property_test (name) values ('test')" name="Insert into table with autoincrement field" type="1"/>
                <node code="select SCOPE_IDENTITY()" name="Get value of the autoincrement field which was just updated" type="1"/>
            </nodes>
        </node>
        <node name="Transact SQL procedures and functions and Sql Developer Techniques" type="0">
            <nodes>
                <node code="create procedure test_proc &#xa;    @param1 int, &#xa;    @param2 varchar(100), &#xa;    @param3 int output, &#xa;    @param4 varchar(100) output&#xa;as&#xa;begin&#xa;    set @param3 = @param1 + 100;&#xa;&#xa;    set @param4 = @param2 + 'test';&#xa;end&#xa;" name="Create stored procedure with input and output parameters (example)" type="1"/>
                <node code="{call test_proc(:param1, :param2, :out_int_param3, :out_varchar_param4)}" name="Execute stored procedure with input and output parameters from Sql Devloper (Execute Script)" type="1"/>
                <node code="create function test_fnc(@v_value int) RETURNS CHAR(6)&#xa;AS  &#xa;BEGIN&#xa;   return CAST(@v_value as char(6));&#xa;END" name="Create function (example)" type="1"/>
                <node code="select dbo.test_fnc(:param) " name="Execute function with input parameters from Sql Developer (Execute Sql)" type="1"/>
                <node code="CREATE FUNCTION result_set()&#xa;RETURNS TABLE&#xa;AS&#xa;RETURN &#xa;(&#xa;    select * from employee&#xa;);" name="Create function which returns resultset" type="1"/>
                <node code="SELECT * FROM dbo.result_set();" name="Execute function which returns resultset from Sql Developer (Execute Sql)" type="1"/>
            </nodes>
        </node>
    </nodes>
</mssqlserver>
